---
phase: 06-observation-lifecycle
plan: 04
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/actions/repeat-findings/detect.ts
  - src/actions/repeat-findings/confirm.ts
  - src/actions/repeat-findings/schemas.ts
autonomous: true

must_haves:
  truths:
    - System detects potential repeat findings by matching branch + audit area + risk category (OBS-09)
    - Detection uses pg_trgm similarity on observation title with 0.5 threshold
    - Repeat finding suggestions include similarity score and occurrence count
    - Auditor can confirm a repeat finding suggestion (OBS-11)
    - Auditor can dismiss a repeat finding suggestion (OBS-11)
    - Confirmed repeat auto-escalates severity per OBS-10 rules
    - Severity escalation creates timeline entry with audit trail
    - Detection runs on save (before SUBMITTED), not after
  artifacts:
    - path: src/actions/repeat-findings/detect.ts
      provides: Server action to detect potential repeat findings using pg_trgm
      exports: ["detectRepeatFindings"]
      min_lines: 40
    - path: src/actions/repeat-findings/confirm.ts
      provides: Server actions to confirm or dismiss repeat finding suggestions
      exports: ["confirmRepeatFinding", "dismissRepeatFinding"]
      min_lines: 50
    - path: src/actions/repeat-findings/schemas.ts
      provides: Zod schemas for repeat finding detection and confirmation
      exports:
        ["DetectRepeatSchema", "ConfirmRepeatSchema", "DismissRepeatSchema"]
      min_lines: 20
  key_links:
    - from: detect.ts
      to: PostgreSQL pg_trgm
      via: Raw SQL query with similarity() function
      pattern: "similarity\\(|\\$queryRaw"
    - from: confirm.ts
      to: state-machine.ts escalateSeverity
      via: Import escalateSeverity for auto-escalation
      pattern: "escalateSeverity"
    - from: confirm.ts
      to: ObservationTimeline
      via: Timeline entries for both severity escalation and repeat confirmation
      pattern: "observationTimeline\\.create"
---

<objective>
Implement repeat finding detection using PostgreSQL pg_trgm similarity matching, and confirmation/dismissal actions with automatic severity escalation.

Purpose: OBS-09/10/11 require the system to detect when an auditor creates an observation that matches a previously closed observation in the same branch and audit area. If confirmed as a repeat, severity auto-escalates: 2nd occurrence = +1 level, 3rd+ = CRITICAL. This is critical for regulatory compliance — RBI expects banks to demonstrate that recurring issues are being tracked and escalated.

Output: 3 server action files covering detection, confirmation, and dismissal of repeat findings with full audit trail.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-observation-lifecycle/06-RESEARCH.md
@.planning/phases/06-observation-lifecycle/06-01-SUMMARY.md
@src/lib/state-machine.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create repeat finding detection server action</name>
  <files>src/actions/repeat-findings/schemas.ts, src/actions/repeat-findings/detect.ts</files>
  <action>
**1. schemas.ts** — Zod schemas:

```typescript
// DetectRepeatSchema — input for detection query
{
  branchId: z.string().uuid(),
  auditAreaId: z.string().uuid(),
  riskCategory: z.string().optional(),
  title: z.string().min(5),
}

// ConfirmRepeatSchema — confirm a specific repeat match
{
  observationId: z.string().uuid(),       // The NEW observation being created
  repeatOfId: z.string().uuid(),          // The OLD observation it repeats
  version: z.number().int().positive(),   // Optimistic lock on new observation
}

// DismissRepeatSchema — dismiss a repeat suggestion
{
  observationId: z.string().uuid(),
  repeatOfId: z.string().uuid(),
}
```

**2. detect.ts** — Detect potential repeat findings:

`detectRepeatFindings` server action:

- Validate input with DetectRepeatSchema.safeParse()
- Get session via getRequiredSession()
- Use prismaForTenant for tenant isolation
- Execute raw SQL query using `prisma.$queryRaw`:

```sql
SELECT
  id,
  title,
  severity,
  status,
  "createdAt",
  similarity(title, $1) as similarity_score
FROM "Observation"
WHERE
  "tenantId" = $2::uuid
  AND "branchId" = $3::uuid
  AND "auditAreaId" = $4::uuid
  AND status = 'CLOSED'
  AND similarity(title, $1) > 0.5
ORDER BY similarity_score DESC
LIMIT 5
```

- For each match, count total CLOSED observations with same (branchId, auditAreaId) to get occurrenceCount
- Return: `{ success: true, data: { candidates: RepeatCandidate[] } }` where RepeatCandidate = `{ id, title, similarity, occurrenceCount, severity, closedAt }`
- If no matches found, return empty candidates array (not an error)

**IMPORTANT:** Because prismaForTenant wraps every query in a transaction with SET LOCAL, the raw query will automatically have the tenant context set. However, still include the tenantId WHERE clause as belt-and-suspenders defense.

If riskCategory is provided, add it as an additional filter: `AND "riskCategory" = $5`
</action>
<verify>Run `pnpm build` to confirm TypeScript compilation. Verify detect.ts uses $queryRaw (not $executeRaw). Verify similarity threshold is 0.5.</verify>
<done>detectRepeatFindings queries PostgreSQL with pg_trgm similarity to find matching closed observations, returns candidates with similarity scores and occurrence counts.</done>
</task>

<task type="auto">
  <name>Task 2: Create repeat finding confirm/dismiss server actions</name>
  <files>src/actions/repeat-findings/confirm.ts</files>
  <action>
**confirmRepeatFinding** server action (OBS-10, OBS-11):

1. Validate with ConfirmRepeatSchema.safeParse()
2. Get session, validate AUDITOR role
3. Fetch both observations (new + old) using prismaForTenant
4. Count total CLOSED observations matching (branchId, auditAreaId) of the old observation
5. Calculate escalated severity using `escalateSeverity(newObservation.severity, occurrenceCount + 1)` from state-machine.ts
6. Atomic transaction:
   a. Update new observation: `{ severity: escalatedSeverity, version: { increment: 1 } }` (only if severity changed)
   b. Create timeline entry for repeat confirmation: `{ event: "repeat_confirmed", oldValue: null, newValue: repeatOfId, comment: "Confirmed as repeat of [old title]. Occurrence #X." }`
   c. If severity changed, create second timeline entry: `{ event: "severity_escalated", oldValue: originalSeverity, newValue: escalatedSeverity, comment: "Auto-escalated due to repeat finding (occurrence #X)" }`
7. revalidatePath for both findings pages
8. Return `{ success: true, data: { id, escalatedSeverity, wasEscalated: boolean } }`

**dismissRepeatFinding** server action (OBS-11):

1. Validate with DismissRepeatSchema.safeParse()
2. Get session, validate AUDITOR role
3. Create timeline entry: `{ event: "repeat_dismissed", oldValue: null, newValue: repeatOfId, comment: "Repeat finding suggestion dismissed by auditor" }`
4. Return `{ success: true }`

No severity change on dismiss — just audit trail record. The auditor is explicitly choosing not to classify it as a repeat, and that decision is recorded.
</action>
<verify>Run `pnpm build` to confirm compilation. Verify confirm.ts imports escalateSeverity from state-machine.ts. Verify both confirm and dismiss create timeline entries. Verify no throw statements.</verify>
<done>confirmRepeatFinding auto-escalates severity and records repeat confirmation in timeline. dismissRepeatFinding records dismissal in timeline without severity change. Both follow return-as-data pattern.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. detect.ts uses raw SQL with pg_trgm similarity function
3. confirm.ts uses escalateSeverity from state-machine.ts
4. All three actions return errors as data (no throw)
5. Both confirm and dismiss create timeline entries (audit trail)
6. Severity escalation is atomic with timeline entry
</verification>

<success_criteria>

- detectRepeatFindings finds similar CLOSED observations using pg_trgm
- confirmRepeatFinding auto-escalates severity per OBS-10 rules with timeline entries
- dismissRepeatFinding records auditor's dismissal decision in timeline
- All actions use session auth, prismaForTenant, Zod validation
- Full audit trail for repeat finding decisions
  </success_criteria>

<output>
After completion, create `.planning/phases/06-observation-lifecycle/06-04-SUMMARY.md`
</output>
