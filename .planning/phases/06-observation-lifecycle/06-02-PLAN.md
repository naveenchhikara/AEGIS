---
phase: 06-observation-lifecycle
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/lib/state-machine.ts
  - src/lib/__tests__/state-machine.test.ts
autonomous: true

must_haves:
  truths:
    - canTransition validates all 7 forward transitions in the linear workflow
    - canTransition validates return-to-draft from SUBMITTED and REVIEWED states
    - AUDITOR can only transition DRAFT -> SUBMITTED
    - AUDIT_MANAGER can review, return, and issue observations
    - AUDIT_MANAGER can close LOW and MEDIUM severity observations
    - CAE can close HIGH and CRITICAL severity observations (OBS-06)
    - AUDITEE can only transition ISSUED -> RESPONSE
    - Invalid transitions return { allowed: false, reason: string }
    - escalateSeverity returns +1 level for 2nd occurrence and CRITICAL for 3rd+ (OBS-10)
    - getAvailableTransitions returns correct options for given state + roles + severity
  artifacts:
    - path: src/lib/state-machine.ts
      provides: canTransition, getAvailableTransitions, escalateSeverity pure functions
      exports: ["canTransition", "getAvailableTransitions", "escalateSeverity", "TRANSITIONS"]
      min_lines: 80
    - path: src/lib/__tests__/state-machine.test.ts
      provides: Exhaustive tests for state machine transitions, role guards, severity-based closing
      min_lines: 120
  key_links:
    - from: state-machine.ts
      to: Prisma enums
      via: Import ObservationStatus, Role, Severity types
      pattern: "ObservationStatus|Role|Severity"
---

<objective>
Build the core state machine logic as pure TypeScript functions with exhaustive test coverage using TDD methodology.

Purpose: The state machine is the central piece of the observation lifecycle. 7 states x 5+ roles = 35+ permission combinations. Building with TDD ensures every transition is verified before server actions consume it. Pure functions (no database, no auth) make testing fast and deterministic.

Output: `state-machine.ts` with canTransition, getAvailableTransitions, escalateSeverity functions. Test file with 20+ test cases covering all valid transitions, invalid transitions, role guards, and severity-based closing rules.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-observation-lifecycle/06-RESEARCH.md
@prisma/schema.prisma
</context>

<feature>
  <name>Observation State Machine</name>
  <files>src/lib/state-machine.ts, src/lib/__tests__/state-machine.test.ts</files>
  <behavior>
**State transitions (forward flow):**
- DRAFT -> SUBMITTED: AUDITOR only
- SUBMITTED -> REVIEWED: AUDIT_MANAGER only
- REVIEWED -> ISSUED: AUDIT_MANAGER only
- ISSUED -> RESPONSE: AUDITEE only
- RESPONSE -> COMPLIANCE: AUDITOR or AUDIT_MANAGER
- COMPLIANCE -> CLOSED: AUDIT_MANAGER (Low/Medium) or CAE (High/Critical)

**Return transitions (maker-checker):**

- SUBMITTED -> DRAFT: AUDIT_MANAGER (return to auditor for revision)
- REVIEWED -> SUBMITTED: AUDIT_MANAGER (return for re-review)

**canTransition(from, to, userRoles, severity?) -> { allowed: boolean, reason?: string }:**

- Valid forward transition with correct role -> { allowed: true }
- Valid forward transition with wrong role -> { allowed: false, reason: "User lacks required role: AUDITOR" }
- Invalid transition (e.g., DRAFT -> CLOSED) -> { allowed: false, reason: "Invalid transition from DRAFT to CLOSED" }
- COMPLIANCE -> CLOSED with severity HIGH and role AUDIT_MANAGER -> { allowed: false, reason: "HIGH severity requires CAE to close" }
- COMPLIANCE -> CLOSED with severity LOW and role AUDIT_MANAGER -> { allowed: true }
- COMPLIANCE -> CLOSED with severity CRITICAL and role CAE -> { allowed: true }

**getAvailableTransitions(currentState, userRoles, severity?) -> Transition[]:**

- DRAFT state, AUDITOR role -> [{ to: "SUBMITTED", label: "Submit for Review" }]
- SUBMITTED state, AUDIT_MANAGER role -> [{ to: "REVIEWED", label: "Approve" }, { to: "DRAFT", label: "Return to Draft" }]
- COMPLIANCE state, AUDIT_MANAGER role, severity LOW -> [{ to: "CLOSED", label: "Close Observation" }]
- COMPLIANCE state, AUDIT_MANAGER role, severity HIGH -> [] (empty — needs CAE)
- COMPLIANCE state, CAE role, severity HIGH -> [{ to: "CLOSED", label: "Close Observation" }]

**escalateSeverity(currentSeverity, occurrenceCount) -> Severity:**

- escalateSeverity("LOW", 1) -> "LOW" (first occurrence, no escalation)
- escalateSeverity("LOW", 2) -> "MEDIUM" (2nd occurrence, +1 level)
- escalateSeverity("MEDIUM", 2) -> "HIGH"
- escalateSeverity("HIGH", 2) -> "CRITICAL"
- escalateSeverity("CRITICAL", 2) -> "CRITICAL" (already max)
- escalateSeverity("LOW", 3) -> "CRITICAL" (3rd+ occurrence = always CRITICAL)
- escalateSeverity("MEDIUM", 4) -> "CRITICAL"
  </behavior>
  <implementation>
  Use TypeScript types that align with Prisma enums (import from `@/generated/prisma` if available, otherwise define locally and note for alignment). Do NOT use Zod for validation in the state machine itself — that belongs in server actions. Keep this module pure TypeScript with zero dependencies beyond types.

The TRANSITIONS array should be a const with the following shape:

```typescript
type TransitionDef = {
  from: ObservationStatus;
  to: ObservationStatus;
  allowedRoles: Role[];
  label: string;
  severityGuard?: (severity: Severity, roles: Role[]) => boolean;
};
```

The severityGuard is only needed for the COMPLIANCE -> CLOSED transition where closing authority depends on severity level.

For tests, use vitest (already likely in devDeps from Phase 5) or jest. Create test file at `src/lib/__tests__/state-machine.test.ts`. Structure tests in describe blocks: "canTransition", "getAvailableTransitions", "escalateSeverity".
</implementation>
</feature>

<verification>
1. All tests pass: `npx vitest run src/lib/__tests__/state-machine.test.ts` (or jest equivalent)
2. Every forward transition has at least one test
3. Every return transition has at least one test
4. Severity-based closing tested for all 4 severity levels
5. escalateSeverity tested for occurrences 1, 2, 3+
6. `pnpm build` succeeds
</verification>

<success_criteria>

- 20+ test cases all passing
- canTransition covers all 8 valid transitions (6 forward + 2 return)
- Invalid transitions rejected with descriptive reason
- Severity-based closing correctly gates AUDIT_MANAGER vs CAE
- escalateSeverity implements OBS-10 rules exactly
- Zero external dependencies (pure TypeScript functions)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-observation-lifecycle/06-02-SUMMARY.md`
</output>
