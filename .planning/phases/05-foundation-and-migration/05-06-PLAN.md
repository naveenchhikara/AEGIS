---
phase: 05-foundation-and-migration
plan: 06
type: execute
wave: 3
depends_on: [05-03, 05-04]
files_modified:
  - src/data-access/settings.ts
  - src/data-access/prisma.ts
  - src/actions/settings.ts
  - src/app/(dashboard)/settings/page.tsx
  - src/components/settings/bank-profile-form.tsx
  - src/components/settings/system-settings.tsx
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - Settings page loads bank profile from PostgreSQL (not JSON)
    - Data Access Layer functions use server-only directive
    - DAL functions accept session object, extract tenantId from session
    - Explicit WHERE tenantId in every DAL query (belt-and-suspenders)
    - Runtime assertion verifies returned data has matching tenantId
    - RBI License Number, Legal Bank Name, State of Registration are read-only after onboarding
    - Fiscal year displays as April-March (hardcoded, not configurable)
  artifacts:
    - path: src/data-access/settings.ts
      provides: Server-only settings queries with tenant scope and runtime assertions
      min_lines: 40
    - path: src/data-access/prisma.ts
      provides: Prisma client with RLS extension (if not already created in 05-02)
      min_lines: 30
    - path: src/actions/settings.ts
      provides: Server action for updating editable settings
      min_lines: 30
    - path: src/app/(dashboard)/settings/page.tsx
      provides: Settings page fetching from PostgreSQL
      min_lines: 25
    - path: src/components/settings/bank-profile-form.tsx
      provides: Bank profile form with read-only and editable fields
      min_lines: 60
  key_links:
    - from: Settings page
      to: Data Access Layer
      via: Server component fetching from PostgreSQL
      pattern: "getTenantSettings"
    - from: DAL functions
      to: Session
      via: getRequiredSession() provides tenantId
      pattern: "getRequiredSession"
    - from: DAL functions
      to: Prisma with RLS
      via: prismaForTenant(tenantId)
      pattern: "prismaForTenant"
---

<objective>
Migrate the Settings page from JSON data to PostgreSQL, establishing the Data Access Layer (DAL) pattern that all subsequent page migrations will follow.

Purpose: Validate the server-fetch → client-render pattern on the simplest page before applying it to complex pages. This creates the reusable DAL template with security guarantees (RLS, explicit WHERE, runtime assertions).

Output: Settings page loading from database with DAL pattern documented for reuse across all 12 remaining pages.

**Key decisions incorporated:**

- D2: Settings page chosen as migration validation target (simplest page)
- D6: Belt-and-suspenders RLS (Skeptic S1) — both RLS AND explicit WHERE tenantId
- S2: tenantId from session ONLY (never from request input)
- DE7: Fiscal year hardcoded April-March (not configurable)
- DE8: DAKSH/PCA/NABARD fields displayed on settings page (nullable)
- DE11: Read-only fields after onboarding (RBI License Number, Legal Bank Name, State of Registration)
- D21: DAKSH/PCA fields nullable — show "Not yet assessed" for null values
  </objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/05-foundation-and-migration/05-02-PLAN.md
@.planning/phases/05-foundation-and-migration/05-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Data Access Layer pattern with settings module</name>
  <files>
    src/data-access/settings.ts
    src/data-access/index.ts
  </files>
  <action>
    Create the canonical Data Access Layer pattern:

    **Settings DAL (src/data-access/settings.ts):**
    ```typescript
    import 'server-only';
    import { getRequiredSession } from './session';
    import { prismaForTenant } from './prisma';

    /**
     * DATA ACCESS LAYER PATTERN (canonical example for all DAL modules):
     *
     * 1. Import 'server-only' — prevents client-side import
     * 2. Call getRequiredSession() — single source of tenantId (Skeptic S2)
     * 3. Use prismaForTenant(tenantId) — RLS isolation
     * 4. Add explicit WHERE tenantId — belt-and-suspenders (Skeptic S1)
     * 5. Runtime assertion — verify returned data matches tenantId
     *
     * SECURITY INVARIANTS:
     * - tenantId MUST come from session ONLY, never from URL/body/query
     * - NEVER use $queryRaw/$executeRaw without explicit tenantId parameter
     * - Every function follows this exact 5-step pattern
     */

    export async function getTenantSettings() {
      // Step 1: Get authenticated session (tenantId source)
      const session = await getRequiredSession();
      const tenantId = session.user.tenantId;

      // Step 2: Get tenant-scoped Prisma client (RLS layer)
      const db = prismaForTenant(tenantId);

      // Step 3: Query with EXPLICIT WHERE tenantId (belt-and-suspenders)
      const tenant = await db.tenant.findFirst({
        where: { id: tenantId },  // Explicit WHERE, not relying solely on RLS
        select: {
          id: true,
          name: true,
          rbiLicenseNumber: true,
          legalBankName: true,
          stateOfRegistration: true,
          ucbTier: true,
          address: true,
          city: true,
          state: true,
          pincode: true,
          phone: true,
          email: true,
          website: true,
          incorporationDate: true,
          // DAKSH/PCA/NABARD fields (DE8, nullable per D21)
          dakshScore: true,
          pcaStatus: true,
          nabardRegistrationNo: true,
          scheduledBankStatus: true,
          lastRbiInspectionDate: true,
          rbiRiskRating: true,
        },
      });

      // Step 4: Runtime assertion (Skeptic S1)
      if (tenant && tenant.id !== tenantId) {
        console.error('CRITICAL: Tenant ID mismatch in getTenantSettings', {
          expected: tenantId,
          received: tenant.id,
        });
        throw new Error('Data isolation violation detected');
      }

      return tenant;
    }
    ```

    **Barrel export (src/data-access/index.ts):**
    ```typescript
    export { getTenantSettings } from './settings';
    export { getRequiredSession, getOptionalSession } from './session';
    // Future exports: observations, compliance, audit-plans, etc.
    ```

    **Document the pattern clearly in code comments — this is the template for ALL future DAL modules.**

  </action>
  <verify>
    pnpm build (no TypeScript errors)
    # Import from client component → build error (server-only directive)
    # Call getTenantSettings() → returns tenant data from PostgreSQL
    # Verify returned tenant.id matches session tenantId
  </verify>
  <done>
    Data Access Layer pattern established with 5-step security process. Settings module is the canonical example for all future DAL functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create settings update server action</name>
  <files>
    src/actions/settings.ts
  </files>
  <action>
    Create server action for updating editable tenant settings:

    **Settings action (src/actions/settings.ts):**
    ```typescript
    'use server';

    import { getRequiredSession } from '@/data-access/session';
    import { prismaForTenant } from '@/data-access/prisma';
    import { setAuditContext } from '@/data-access/audit-context';
    import { hasPermission } from '@/lib/permissions';
    import { revalidatePath } from 'next/cache';
    import { headers } from 'next/headers';
    import { z } from 'zod';

    const settingsSchema = z.object({
      address: z.string().optional(),
      city: z.string().optional(),
      state: z.string().optional(),
      pincode: z.string().max(6).optional(),
      phone: z.string().optional(),
      email: z.string().email().optional(),
      website: z.string().url().optional(),
      // READ-ONLY fields NOT included in schema (DE11):
      // rbiLicenseNumber, legalBankName, stateOfRegistration — cannot be updated
    });

    export async function updateTenantSettings(formData: z.infer<typeof settingsSchema>) {
      const session = await getRequiredSession();

      // Permission check
      if (!hasPermission(session.user.roles, 'admin:manage_settings')) {
        throw new Error('Insufficient permissions');
      }

      const validated = settingsSchema.parse(formData);
      const tenantId = session.user.tenantId;
      const db = prismaForTenant(tenantId);

      await db.$transaction(async (tx) => {
        // Set audit context
        await setAuditContext(tx, {
          actionType: 'tenant.settings_updated',
          userId: session.user.id,
          tenantId: tenantId,
          ipAddress: (await headers()).get('x-forwarded-for') ?? '',
          sessionId: session.session.id,
        });

        // Update with explicit WHERE tenantId
        await tx.tenant.update({
          where: { id: tenantId },
          data: validated,
        });
      });

      revalidatePath('/settings');
    }
    ```

    **IMPORTANT (DE11):** The following fields are READ-ONLY after onboarding and MUST NOT be in the update schema:
    - RBI License Number
    - Legal Bank Name
    - State of Registration
    - Fiscal Year Start (hardcoded April-March, DE7)

    These fields are set during onboarding (Phase 9) and can never be changed via the Settings UI.

  </action>
  <verify>
    # Update address → tenant record updated in database
    # Attempt to update rbiLicenseNumber → rejected (not in schema)
    # Check audit_log → entry with action_type='tenant.settings_updated'
    # Non-admin user → permission denied
  </verify>
  <done>
    Settings update server action with Zod validation, permission check, audit context, and read-only field protection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Migrate Settings page to fetch from PostgreSQL</name>
  <files>
    src/app/(dashboard)/settings/page.tsx
    src/components/settings/bank-profile-form.tsx
  </files>
  <action>
    Migrate Settings page from JSON data to PostgreSQL:

    **Settings page (src/app/(dashboard)/settings/page.tsx):**
    - Server component
    - Call `requirePermission('admin:manage_settings')` for access guard
    - Call `getTenantSettings()` from DAL (fetches from PostgreSQL)
    - Pass tenant data as props to BankProfileForm client component
    - This demonstrates the server-fetch → client-render pattern

    **BEFORE (current implementation — JSON data):**
    The current settings page likely imports from `@/data` and displays bank profile from JSON.

    **AFTER (new implementation — PostgreSQL):**
    ```typescript
    import { requirePermission } from '@/lib/guards';
    import { getTenantSettings } from '@/data-access/settings';
    import { BankProfileForm } from '@/components/settings/bank-profile-form';

    export default async function SettingsPage() {
      const session = await requirePermission('admin:manage_settings');
      const settings = await getTenantSettings();

      if (!settings) {
        return <div>Bank profile not found. Please complete onboarding.</div>;
      }

      return (
        <div className="space-y-6">
          <div>
            <h1 className="text-2xl font-semibold">Settings</h1>
            <p className="text-muted-foreground">Manage your bank profile and system settings.</p>
          </div>
          <BankProfileForm settings={settings} />
        </div>
      );
    }
    ```

    **Bank profile form (src/components/settings/bank-profile-form.tsx):**
    - "use client" component
    - Display ALL Tenant model fields in organized sections:
      1. **Bank Identity (read-only after onboarding, DE11):**
         - RBI License Number (disabled input, gray background)
         - Legal Bank Name (disabled input)
         - State of Registration (disabled input)
         - UCB Tier (disabled input)
      2. **Contact Information (editable):**
         - Address, City, State, Pincode, Phone, Email, Website
      3. **Regulatory Information (read-only display, DE8):**
         - DAKSH Score — show "Not yet assessed" if null (D21)
         - PCA Status — show "Not under PCA" if null
         - NABARD Registration No — show "N/A" if null
         - Scheduled Bank Status — Yes/No badge
         - Last RBI Inspection Date — show "Not recorded" if null
         - RBI Risk Rating — show if available
      4. **Financial Year:**
         - Display "April - March" (hardcoded, not editable, DE7)
         - Show current quarter indicator

    - Submit button saves only editable fields via `updateTenantSettings` server action
    - Show loading state during save
    - Show success/error toast after save

    **IMPORTANT:** Read-only fields have `disabled` attribute and visual distinction (gray background).
    The Zod schema in the server action ensures read-only fields cannot be modified even if the client tries.

  </action>
  <verify>
    Navigate to /settings → data loads from PostgreSQL (not JSON)
    Edit address → save → data persisted to database
    RBI License Number field → disabled, cannot be edited
    DAKSH Score null → shows "Not yet assessed"
    Fiscal Year → shows "April - March" (not editable)
    Check audit_log → entry for settings update
    Non-admin user → redirected (cannot access settings)
  </verify>
  <done>
    Settings page migrated to PostgreSQL. DAL pattern (server-fetch → client-render) validated and documented as template for all future page migrations.
  </done>
</task>

<task type="auto">
  <name>Task 4: Document DAL pattern and verify build</name>
  <files>
    src/data-access/README.md
  </files>
  <action>
    Document the DAL pattern for future page migrations and verify everything builds:

    **README (src/data-access/README.md):**
    Document the 5-step DAL pattern with:
    1. `import 'server-only'` — prevents client-side import
    2. `getRequiredSession()` — single source of tenantId (never from request input)
    3. `prismaForTenant(tenantId)` — RLS isolation at database level
    4. Explicit `WHERE tenantId` — belt-and-suspenders with RLS
    5. Runtime assertion — verify returned data matches tenantId

    Include:
    - Copy-paste template for new DAL modules
    - List of security invariants
    - Common mistakes to avoid (importing in client components, using $queryRaw without tenantId)
    - Migration checklist for converting each page from JSON to PostgreSQL

    **Verify full build:**
    ```bash
    pnpm build
    ```
    Must complete without TypeScript errors. The migration from JSON to DB for settings should not break any other pages (they still use JSON data).

  </action>
  <verify>
    pnpm build (no errors)
    # All existing pages still work (JSON data)
    # Settings page works from PostgreSQL
    # DAL README exists with pattern documentation
  </verify>
  <done>
    DAL pattern documented. Full build passes. Settings page validated as migration template. Phase 5 data access pattern established for 12 remaining page migrations.
  </done>
</task>

</tasks>

<verification>
**Settings page validation:**
1. Settings page loads bank profile from PostgreSQL (not JSON)
2. Editable fields can be updated and persisted
3. Read-only fields (RBI License, Legal Name, State) are disabled in UI
4. Read-only fields cannot be updated via server action (Zod rejects them)
5. DAKSH/PCA/NABARD fields display correctly (null → "Not yet assessed")
6. Fiscal year shows "April - March" (hardcoded, not configurable)
7. Audit log entry created for settings updates
8. Non-admin users cannot access settings page

**DAL pattern validation:** 9. DAL functions use server-only directive (cannot be imported client-side) 10. All DAL functions call getRequiredSession() (tenantId from session only) 11. All DAL functions use prismaForTenant() (RLS isolation) 12. All DAL functions have explicit WHERE tenantId (belt-and-suspenders) 13. All DAL functions have runtime assertion (tenantId mismatch → throw) 14. Full build passes (no TypeScript errors)

**Migration pattern validation:** 15. Server-fetch → client-render pattern works correctly 16. Client component receives data as props (no async in client) 17. Server action handles mutations with proper validation 18. Pattern is documented and reusable for all 12 remaining pages
</verification>

<success_criteria>

1. Settings page loads from PostgreSQL with all Tenant fields displayed
2. Read-only fields enforced both in UI and server action
3. DAL 5-step pattern implemented and documented
4. Runtime assertion catches potential tenantId mismatches
5. pnpm build succeeds with no TypeScript errors
   </success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-and-migration/05-06-SUMMARY.md`
</output>
