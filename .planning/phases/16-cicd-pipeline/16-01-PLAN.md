---
phase: 16-cicd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
autonomous: true

user_setup:
  - service: github-secrets
    why: "Coolify deployment trigger requires webhook URL and API token"
    env_vars:
      - name: COOLIFY_WEBHOOK_URL
        source: "Coolify dashboard -> Application -> Webhooks"
      - name: COOLIFY_API_TOKEN
        source: "Coolify dashboard -> User Settings -> API Tokens -> Generate"

must_haves:
  truths:
    - "Push to main triggers lint, typecheck, build, and E2E test jobs"
    - "Pull request to main triggers lint, typecheck, build, and E2E test jobs"
    - "E2E tests run against fresh PostgreSQL with seeded test data"
    - "Successful push to main triggers Coolify deployment webhook when secrets are configured (skips gracefully when not)"
    - "Stale PR runs are canceled but main branch runs are preserved"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Complete CI/CD pipeline definition"
      contains: "lint|typecheck|build|e2e|deploy"
  key_links:
    - from: ".github/workflows/ci.yml (e2e job)"
      to: "playwright.config.ts"
      via: "pnpm test:e2e command"
      pattern: "pnpm test:e2e"
    - from: ".github/workflows/ci.yml (e2e job)"
      to: "prisma/seed.ts"
      via: "pnpm db:seed for test data"
      pattern: "pnpm db:seed|prisma db seed"
    - from: ".github/workflows/ci.yml (deploy job)"
      to: "Coolify webhook"
      via: "curl GET with Bearer token"
      pattern: "COOLIFY_WEBHOOK_URL"
---

<objective>
Create a GitHub Actions CI/CD workflow that automates testing (lint, type-check, build, Playwright E2E) on every push/PR to main, and triggers Coolify deployment on successful main pushes.

Purpose: Prevent regressions by validating every change before merge and automate deployment to eliminate manual Coolify dashboard deploys.
Output: `.github/workflows/ci.yml` with 5 jobs (lint, typecheck, build, e2e, deploy)
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cicd-pipeline/16-RESEARCH.md
@playwright.config.ts
@src/env.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI workflow with lint, typecheck, build, and E2E jobs</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Create `.github/workflows/ci.yml` with the following structure:

**Triggers:** `push` to `main`, `pull_request` to `main`

**Concurrency:** Group by `${{ github.workflow }}-${{ github.ref }}`, cancel-in-progress only for non-main branches (`${{ github.ref != 'refs/heads/main' }}`).

**4 validation jobs (lint, typecheck, build run in parallel; e2e runs independently):**

1. **lint** job:
   - ubuntu-latest runner
   - Checkout, pnpm/action-setup@v4 (version 10), actions/setup-node@v4 (node 22, cache: pnpm)
   - `pnpm install --frozen-lockfile`
   - `pnpm prisma generate` (next lint loads next.config.ts which imports src/env.ts — Prisma client must exist)
   - `pnpm lint` with env: `SKIP_ENV_VALIDATION: "1"` (CRITICAL: `next lint` loads next.config.ts which imports `./src/env` — without this, env validation fails in CI)

2. **typecheck** job:
   - Same runner/setup as lint
   - `pnpm install --frozen-lockfile`
   - `pnpm prisma generate` (required before tsc can resolve @prisma/client types)
   - `pnpm tsc --noEmit`

3. **build** job:
   - Same runner/setup as lint
   - Add actions/cache@v4 for Next.js build cache:
     - path: `${{ github.workspace }}/.next/cache`
     - key: `${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}`
     - restore-keys: `${{ runner.os }}-nextjs-${{ hashFiles('**/pnpm-lock.yaml') }}-`
   - `pnpm install --frozen-lockfile`
   - `pnpm prisma generate`
   - `pnpm build` with env: `SKIP_ENV_VALIDATION: "1"` and `DATABASE_URL: "postgresql://ci:ci@localhost:5432/ci"` (dummy URL needed even with skip validation)

4. **e2e** job:
   - PostgreSQL 16-alpine service container:
     - POSTGRES_USER: aegis, POSTGRES_PASSWORD: testpassword123, POSTGRES_DB: aegis_test
     - Health check: `pg_isready`, interval 10s, timeout 5s, retries 5
     - Port mapping: 5432:5432
   - Same runner/pnpm/node setup
   - `pnpm install --frozen-lockfile`
   - `pnpm prisma generate`
   - `pnpm prisma db push` with DATABASE_URL env
   - `pnpm db:seed` with DATABASE_URL env
   - Cache Playwright browsers using actions/cache@v4:
     - path: `~/.cache/ms-playwright`
     - key: `${{ runner.os }}-playwright-${{ hashFiles('**/pnpm-lock.yaml') }}`
     - restore-keys: `${{ runner.os }}-playwright-`
   - `pnpm exec playwright install --with-deps chromium` (use `pnpm exec` to ensure matching version from lockfile, chromium only)
   - `pnpm test:e2e` with full env block:
     - DATABASE_URL: `postgresql://aegis:testpassword123@localhost:5432/aegis_test`
     - BETTER_AUTH_SECRET: `ci_test_secret_that_is_at_least_32chars_long`
     - BETTER_AUTH_URL: `http://localhost:3000`
     - NEXT_PUBLIC_APP_URL: `http://localhost:3000`
     - AWS_REGION: `ap-south-1`
     - AWS_ACCESS_KEY_ID: `test`
     - AWS_SECRET_ACCESS_KEY: `test`
     - S3_BUCKET_NAME: `test-bucket`
     - NODE_ENV: `test`
     - POSTGRES_USER: `aegis`
     - POSTGRES_PASSWORD: `testpassword123`
     - POSTGRES_DB: `aegis_test`
     - POSTGRES_PORT: `5432`
   - Upload playwright-report/ artifact on failure only (actions/upload-artifact@v4, retention 30 days)

**IMPORTANT notes:**

- Database password is alphanumeric only (no special chars per project constraint)
- BETTER_AUTH_SECRET must be >= 32 chars
- E2E env vars must satisfy T3 Env validation schema in src/env.ts (all required server vars provided)
- All 4 validation jobs have NO `needs:` dependency on each other (they run in parallel)
  </action>
  <verify>
  Validate YAML syntax: `node -e "const yaml = require('yaml'); const fs = require('fs'); yaml.parse(fs.readFileSync('.github/workflows/ci.yml', 'utf8')); console.log('Valid YAML')"` (yaml package available via pnpm, or use `npx yaml-lint .github/workflows/ci.yml`)
  Verify 5 jobs defined: `grep -c "runs-on:" .github/workflows/ci.yml` should return 5
  Verify triggers: `grep "push:" .github/workflows/ci.yml && grep "pull_request:" .github/workflows/ci.yml`
  Verify service container: `grep "postgres:" .github/workflows/ci.yml`
  Verify SKIP_ENV_VALIDATION set for lint job: `grep -A20 "lint:" .github/workflows/ci.yml | grep "SKIP_ENV_VALIDATION"`
  Verify env vars match src/env.ts required fields
  </verify>
  <done>CI workflow YAML exists with 4 parallel validation jobs (lint, typecheck, build, e2e), PostgreSQL service container with health checks, pnpm caching, Next.js build cache, Playwright browser caching, and artifact upload on failure</done>
  </task>

<task type="auto">
  <name>Task 2: Add Coolify deploy job triggered after all checks pass on main</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Add a 5th job `deploy` to the existing `.github/workflows/ci.yml`:

```yaml
deploy:
  runs-on: ubuntu-latest
  needs: [lint, typecheck, build, e2e]
  if: github.ref == 'refs/heads/main' && github.event_name == 'push' && secrets.COOLIFY_WEBHOOK_URL != ''
  steps:
    - name: Trigger Coolify deployment
      run: |
        curl --fail --silent --show-error --location \
          -X GET "${{ secrets.COOLIFY_WEBHOOK_URL }}" \
          -H "Authorization: Bearer ${{ secrets.COOLIFY_API_TOKEN }}"
```

Key details:

- `needs: [lint, typecheck, build, e2e]` ensures deploy only runs after ALL checks pass
- `if` condition ensures deploy only runs on push to main (not PRs) AND only when COOLIFY_WEBHOOK_URL secret is set (prevents every main push from failing before secrets are configured)
- `curl --fail` returns non-zero exit code on HTTP errors (4xx/5xx), failing the job visibly
- `--silent --show-error` suppresses progress but shows errors
- `--location` follows HTTP redirects (tolerates Coolify URL redirects)
- Uses repository secrets COOLIFY_WEBHOOK_URL and COOLIFY_API_TOKEN (user must add these in GitHub Settings -> Secrets)
- GET method per Coolify documentation
  </action>
  <verify>
  Verify deploy job exists: `grep "deploy:" .github/workflows/ci.yml`
  Verify needs all 4 jobs: `grep -A1 "needs:" .github/workflows/ci.yml | grep "lint, typecheck, build, e2e"`
  Verify main-only condition: `grep "refs/heads/main" .github/workflows/ci.yml`
  Verify secrets usage: `grep "COOLIFY_WEBHOOK_URL" .github/workflows/ci.yml && grep "COOLIFY_API_TOKEN" .github/workflows/ci.yml`
  Full YAML validation: `node -e "const yaml = require('yaml'); const fs = require('fs'); yaml.parse(fs.readFileSync('.github/workflows/ci.yml', 'utf8')); console.log('Valid YAML')"`
  </verify>
  <done>Deploy job added that triggers Coolify webhook only after all 4 validation jobs pass on main branch push, using repository secrets for authentication</done>
  </task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` exists and is valid YAML
2. 5 jobs defined: lint, typecheck, build, e2e, deploy
3. lint, typecheck, build have no inter-dependencies (parallel)
4. e2e has PostgreSQL service container with health checks
5. deploy needs all 4 validation jobs and only runs on main push
6. Concurrency configured: cancel stale PR runs, preserve main runs
7. pnpm caching via setup-node cache: 'pnpm'
8. Next.js build cache via actions/cache@v4
9. Playwright chromium-only install
10. All env vars in e2e job satisfy T3 Env schema (src/env.ts)
</verification>

<success_criteria>

- GitHub Actions workflow file is valid YAML at `.github/workflows/ci.yml`
- Push to main or PR to main triggers the 4 validation jobs
- E2E job provisions ephemeral PostgreSQL, runs schema push + seed + Playwright
- Deploy job triggers Coolify webhook only on successful main push
- Concurrency prevents resource waste without canceling main deployments
  </success_criteria>

<output>
After completion, create `.planning/phases/16-cicd-pipeline/16-01-SUMMARY.md`
</output>
