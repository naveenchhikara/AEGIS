---
phase: 06-observation-lifecycle
plan: 03
type: execute
wave: 2
depends_on: [06-01, 06-02]
files_modified:
  - src/actions/observations/schemas.ts
  - src/actions/observations/create.ts
  - src/actions/observations/transition.ts
  - src/actions/observations/resolve-fieldwork.ts
  - src/data-access/observations.ts
autonomous: true

must_haves:
  truths:
    - Auditor can create observation in DRAFT state with 5C fields (OBS-01)
    - Every state transition atomically updates status AND creates timeline entry (OBS-03)
    - Optimistic locking rejects concurrent transitions with stale version
    - Audit Manager can return observation to DRAFT from SUBMITTED (OBS-04)
    - Auditor can mark observation as resolved during fieldwork with reason (OBS-07)
    - All server actions return { success, data?, error? } pattern (never throw)
    - Server actions validate input with Zod schemas
    - Server actions check auth session and roles before any mutation
  artifacts:
    - path: src/actions/observations/schemas.ts
      provides: Zod schemas for create, transition, and resolve-fieldwork actions
      exports:
        [
          "CreateObservationSchema",
          "TransitionObservationSchema",
          "ResolveFieldworkSchema",
        ]
      min_lines: 40
    - path: src/actions/observations/create.ts
      provides: Server action to create observation in DRAFT state
      exports: ["createObservation"]
      min_lines: 50
    - path: src/actions/observations/transition.ts
      provides: Generic server action for any state transition with role validation
      exports: ["transitionObservation"]
      min_lines: 70
    - path: src/actions/observations/resolve-fieldwork.ts
      provides: Server action to mark observation as resolved during fieldwork (OBS-07)
      exports: ["resolveFieldwork"]
      min_lines: 30
    - path: src/data-access/observations.ts
      provides: Server-only DAL functions for observation queries
      exports:
        ["getObservations", "getObservationById", "getObservationSummary"]
      min_lines: 60
  key_links:
    - from: transition.ts
      to: state-machine.ts
      via: canTransition validation before any status change
      pattern: "canTransition"
    - from: transition.ts
      to: Prisma
      via: Atomic transaction updating status + creating timeline entry
      pattern: "\\$transaction|prismaForTenant"
    - from: create.ts
      to: session.ts
      via: getRequiredSession for auth + tenant context
      pattern: "getRequiredSession"
    - from: observations DAL
      to: Prisma
      via: prismaForTenant with WHERE tenantId clause (belt-and-suspenders)
      pattern: "prismaForTenant.*tenantId"
---

<objective>
Implement server actions for observation CRUD and all state transitions, plus Data Access Layer queries for reading observations from PostgreSQL.

Purpose: Server actions are the mutation backbone of the observation lifecycle. Every state transition must validate auth, check roles via the state machine, update status, and record an immutable timeline entry — all atomically. The DAL provides server-only query functions that replace JSON file imports.

Output: 4 server action files (create, transition, resolve-fieldwork, schemas) + 1 DAL file. All follow Phase 5 patterns: return errors as data, getRequiredSession for auth, prismaForTenant for RLS.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-foundation-and-migration/05-02-SUMMARY.md
@.planning/phases/06-observation-lifecycle/06-RESEARCH.md
@.planning/phases/06-observation-lifecycle/06-01-SUMMARY.md
@.planning/phases/06-observation-lifecycle/06-02-SUMMARY.md
@src/lib/prisma.ts
@src/lib/state-machine.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod schemas and observation CRUD server actions</name>
  <files>src/actions/observations/schemas.ts, src/actions/observations/create.ts, src/actions/observations/resolve-fieldwork.ts</files>
  <action>
**1. schemas.ts** — Zod validation schemas:

```typescript
// CreateObservationSchema (OBS-01: 5C format)
{
  title: z.string().min(5, "Title must be at least 5 characters").max(200),
  condition: z.string().min(10, "Condition must be at least 10 characters"),
  criteria: z.string().min(10, "Criteria must be at least 10 characters"),
  cause: z.string().min(10, "Cause must be at least 10 characters"),
  effect: z.string().min(10, "Effect must be at least 10 characters"),
  recommendation: z.string().min(10, "Recommendation must be at least 10 characters"),
  severity: z.enum(["LOW", "MEDIUM", "HIGH", "CRITICAL"]),
  branchId: z.string().uuid().optional(),
  auditAreaId: z.string().uuid().optional(),
  assignedToId: z.string().uuid().optional(),
  riskCategory: z.string().optional(),
  dueDate: z.string().datetime().optional(),
}

// TransitionObservationSchema (OBS-02, OBS-03)
{
  observationId: z.string().uuid(),
  targetStatus: z.enum(["SUBMITTED", "REVIEWED", "DRAFT", "ISSUED", "RESPONSE", "COMPLIANCE", "CLOSED"]),
  comment: z.string().min(1, "Comment required for state transitions"),
  version: z.number().int().positive(), // Optimistic locking
  // Optional fields for RESPONSE state
  auditeeResponse: z.string().optional(),
  actionPlan: z.string().optional(),
}

// ResolveFieldworkSchema (OBS-07)
{
  observationId: z.string().uuid(),
  resolutionReason: z.string().min(10, "Resolution reason must be at least 10 characters"),
  version: z.number().int().positive(),
}
```

**2. create.ts** — Create observation in DRAFT state:

- Use `"use server"` directive
- Get session via `getRequiredSession()` (from Phase 5 `src/data-access/session.ts`)
- Validate user has AUDITOR role (using permissions check)
- Validate input with CreateObservationSchema.safeParse()
- Use `prismaForTenant(session.user.tenantId)` for tenant-scoped Prisma
- Create observation with `status: "DRAFT"` and `version: 1`
- Create initial timeline entry: `{ event: "created", newValue: "DRAFT", comment: "Observation created" }`
- Both in a single `$transaction`
- Return `{ success: true, data: { id } }` or `{ success: false, error: string }`
- Call `revalidatePath("/findings")` after success

**3. resolve-fieldwork.ts** — Mark observation as resolved during fieldwork (OBS-07):

- Use `"use server"` directive
- Get session, validate AUDITOR or AUDIT_MANAGER role
- Validate with ResolveFieldworkSchema.safeParse()
- Verify observation is in DRAFT or SUBMITTED state (only pre-issued observations can be resolved)
- Optimistic lock check: `where: { id, version }`
- Update: `{ resolvedDuringFieldwork: true, resolutionReason, version: { increment: 1 } }`
- Create timeline entry: `{ event: "resolved_during_fieldwork", comment: resolutionReason }`
- Return standard result pattern

**CRITICAL patterns (from Phase 5 and research):**

- NEVER throw errors — always return `{ success: false, error }` for useActionState compatibility
- ALWAYS use `safeParse`, not `parse`
- ALWAYS call `revalidatePath` after mutations
- ALWAYS use `prismaForTenant` (not raw `prisma`)
- Belt-and-suspenders: include `tenantId` in WHERE clauses even with RLS
  </action>
  <verify>Run `pnpm build` to confirm TypeScript compilation. Verify files use "use server" directive. Verify no throw statements in server actions (grep for "throw" in the files).</verify>
  <done>createObservation creates DRAFT observation with timeline entry. resolveFieldwork marks observation as resolved during fieldwork. Both use Zod validation, session auth, prismaForTenant, and return errors as data.</done>
  </task>

<task type="auto">
  <name>Task 2: Create generic state transition server action and observation DAL</name>
  <files>src/actions/observations/transition.ts, src/data-access/observations.ts</files>
  <action>
**1. transition.ts** — Generic state transition action handling ALL transitions (OBS-02 through OBS-06):

Instead of separate actions per transition, use ONE `transitionObservation` action that:

- Validates input with TransitionObservationSchema.safeParse()
- Gets session via getRequiredSession()
- Fetches current observation (with tenant scope)
- Calls `canTransition(currentStatus, targetStatus, userRoles, severity)` from state-machine.ts
- If not allowed, returns `{ success: false, error: transition.reason }`
- Optimistic lock: query with `where: { id: observationId, version: input.version }`
- If observation not found (version mismatch), return `{ success: false, error: "Observation was modified by another user. Please refresh and try again." }`
- Atomic transaction:
  1. Update observation: `{ status: targetStatus, statusUpdatedAt: new Date(), version: { increment: 1 } }`
  2. If targetStatus is RESPONSE, also update: `{ auditeeResponse: input.auditeeResponse, actionPlan: input.actionPlan }`
  3. Create timeline entry: `{ event: "status_changed", oldValue: currentStatus, newValue: targetStatus, comment: input.comment, createdById: session.user.id }`
- revalidatePath("/findings") and revalidatePath(`/findings/${observationId}`)
- Return `{ success: true, data: { id, newStatus } }`

**Key: Version increment uses Prisma's atomic `{ increment: 1 }` — not read-then-write.**

**2. observations.ts** — Data Access Layer (server-only):

Add `import "server-only"` at top (install `server-only` package if not present).

Functions:

```typescript
// Get paginated observations list with summary counts
export async function getObservations(
  session: Session,
  options?: {
    severity?: string;
    status?: string;
    branchId?: string;
    auditAreaId?: string;
    page?: number;
    pageSize?: number;
  },
): Promise<{ observations: Observation[]; total: number }>;

// Get single observation with timeline and related data
export async function getObservationById(
  session: Session,
  id: string,
): Promise<Observation | null>;

// Get summary counts (by severity, by status)
export async function getObservationSummary(session: Session): Promise<{
  total: number;
  bySeverity: Record<string, number>;
  byStatus: Record<string, number>;
}>;
```

Each function:

- Accepts `session` object (from getRequiredSession)
- Extracts tenantId from session
- Uses `prismaForTenant(tenantId)`
- Adds explicit `WHERE tenantId` in every query (belt-and-suspenders per Phase 5 pattern)
- `getObservationById` includes: timeline (ordered by createdAt ASC), branch, auditArea, assignedTo, createdBy, rbiCirculars (via junction table)
- `getObservationSummary` uses `groupBy` for severity and status counts

Follow the same pattern as `src/data-access/settings.ts` from Phase 5 Plan 06.
</action>
<verify>Run `pnpm build` to confirm compilation. Verify transition.ts imports canTransition from state-machine.ts. Verify observations.ts uses "server-only" import. Verify no throw statements in transition.ts.</verify>
<done>transitionObservation handles all state transitions with role validation, optimistic locking, and atomic timeline recording. observations.ts DAL provides getObservations, getObservationById, getObservationSummary with tenant-scoped queries.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds with all new files
2. All server actions use "use server" directive
3. No throw statements in server action files (errors returned as data)
4. transitionObservation uses canTransition from state-machine.ts
5. Optimistic locking uses `version` field with `{ increment: 1 }`
6. Every mutation creates a timeline entry
7. observations.ts uses "server-only" import
8. All DAL functions accept session object (not raw tenantId)
</verification>

<success_criteria>

- createObservation creates DRAFT observation with 5C fields and initial timeline entry
- transitionObservation handles all 8 transitions (6 forward + 2 return) with role validation
- resolveFieldwork marks observations as resolved during fieldwork (OBS-07)
- Optimistic locking prevents concurrent transition conflicts
- observations DAL provides list, detail, and summary queries
- All functions follow Phase 5 patterns: return-as-data, prismaForTenant, session-based auth
  </success_criteria>

<output>
After completion, create `.planning/phases/06-observation-lifecycle/06-03-SUMMARY.md`
</output>
