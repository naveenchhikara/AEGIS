---
phase: 05-foundation-and-migration
plan: 05
type: execute
wave: 3
depends_on: [05-03, 05-04]
files_modified:
  - prisma/migrations/YYYYMMDD_audit_trigger/migration.sql
  - src/data-access/audit-context.ts
  - src/data-access/audit-trail.ts
  - src/app/(dashboard)/audit-trail/page.tsx
  - src/components/audit-trail/audit-trail-table.tsx
  - src/components/audit-trail/audit-trail-filters.tsx
autonomous: true

must_haves:
  truths:
    - Every data mutation creates an audit log entry automatically via PostgreSQL trigger
    - Audit log entries cannot be modified or deleted by aegis_app role
    - Audit log has sequenceNumber BIGSERIAL for gap detection
    - Business-level actionType stored (e.g. observation.created, user.role_changed)
    - CAE can view and filter audit trail by entity, user, date, action type
    - 10-year retention default (retentionExpiresAt column)
  artifacts:
    - path: prisma/migrations/YYYYMMDD_audit_trigger/migration.sql
      provides: PostgreSQL trigger function for automatic audit logging
      min_lines: 50
    - path: src/data-access/audit-context.ts
      provides: Utility to set action context before mutations
      min_lines: 20
    - path: src/data-access/audit-trail.ts
      provides: Server-only audit trail queries with filters
      min_lines: 40
    - path: src/app/(dashboard)/audit-trail/page.tsx
      provides: CAE audit trail viewer page
      min_lines: 30
  key_links:
    - from: PostgreSQL trigger
      to: audit_log table
      via: Automatic INSERT on every tenant table mutation
      pattern: "TG_OP|OLD|NEW"
    - from: Application code
      to: PostgreSQL trigger
      via: set_config('app.current_action', ...)
      pattern: "set_config.*app\\.current_action"
    - from: Audit trail page
      to: audit_trail DAL
      via: Server component query
      pattern: "getAuditTrailEntries"
---

<objective>
Implement comprehensive audit trail with PostgreSQL triggers, business-level action types, justification capture, and CAE viewer page.

Purpose: Provide complete, tamper-evident audit trail for all data mutations — required for RBI inspection readiness and PMLA compliance. CAE must be able to search and filter the audit trail for governance oversight.

Output: Automatic audit logging on every tenant table mutation, immutable entries (INSERT+SELECT only for app role), CAE audit trail viewer with filters and export.

**Key decisions incorporated:**

- D14: 10-year audit trail retention (PMLA 2002)
- D15: Business action_type + justification in audit_log (DE5, DE6)
- D9: Hash chaining deferred to V2.1 (INSERT-only + sequence_number sufficient for pilot)
- DE2: INSERT-only audit_log enforced at DB role level (REVOKE + RULES)
- DE3: 10-year retention with retentionExpiresAt column
- S4: BIGSERIAL sequence_number for gap detection
  </objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@.planning/phases/05-foundation-and-migration/05-02-PLAN.md
@.planning/phases/05-foundation-and-migration/05-03-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL audit trigger function</name>
  <files>
    prisma/migrations/YYYYMMDD_audit_trigger/migration.sql
  </files>
  <action>
    Create PostgreSQL trigger function that automatically logs all mutations on tenant-scoped tables:

    **NOTE:** The audit_log table schema is already defined in 05-02 Prisma schema. This task adds the trigger function and attaches it to all tenant-scoped tables.

    **Trigger function (create via Prisma migration SQL):**
    ```sql
    CREATE OR REPLACE FUNCTION audit_trigger_function()
    RETURNS TRIGGER AS $$
    DECLARE
      _action_type TEXT;
      _justification TEXT;
      _ip_address TEXT;
      _session_id TEXT;
      _user_id TEXT;
      _tenant_id TEXT;
    BEGIN
      -- Read application context set by Prisma before mutation
      _action_type := current_setting('app.current_action', TRUE);
      _justification := current_setting('app.current_justification', TRUE);
      _ip_address := current_setting('app.current_ip_address', TRUE);
      _session_id := current_setting('app.current_session_id', TRUE);
      _user_id := current_setting('app.current_user_id', TRUE);
      _tenant_id := current_setting('app.current_tenant_id', TRUE);

      INSERT INTO "AuditLog" (
        id,
        "tenantId",
        "userId",
        "tableName",
        "recordId",
        operation,
        "actionType",
        justification,
        "oldData",
        "newData",
        "ipAddress",
        "sessionId",
        "retentionExpiresAt",
        "createdAt"
      ) VALUES (
        gen_random_uuid(),
        _tenant_id,
        _user_id,
        TG_TABLE_NAME,
        CASE
          WHEN TG_OP = 'DELETE' THEN OLD.id::TEXT
          ELSE NEW.id::TEXT
        END,
        TG_OP,
        _action_type,
        _justification,
        CASE WHEN TG_OP IN ('UPDATE', 'DELETE') THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN to_jsonb(NEW) ELSE NULL END,
        _ip_address,
        _session_id,
        NOW() + INTERVAL '10 years',  -- DE3: PMLA 10-year retention
        NOW()
      );

      RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
    END;
    $$ LANGUAGE plpgsql;
    ```

    **Attach trigger to ALL tenant-scoped tables:**
    ```sql
    -- List of all tenant-scoped tables (must match 05-02 schema):
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "Tenant" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "User" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "Branch" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "AuditArea" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "AuditPlan" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "AuditEngagement" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "Observation" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "ComplianceRequirement" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "Finding" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    CREATE TRIGGER audit_trigger AFTER INSERT OR UPDATE OR DELETE ON "EvidenceFile" FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();
    ```

    **IMPORTANT:** Do NOT attach trigger to AuditLog table itself (would cause infinite recursion).

    **Create migration via Prisma:**
    Use `pnpm prisma migrate dev --create-only --name audit_trigger` to create empty migration, then paste SQL.

  </action>
  <verify>
    # Insert a test record → check audit_log has entry
    # Update a test record → check audit_log has old_data and new_data
    # Delete a test record → check audit_log has old_data
    # Verify sequence_number auto-increments
    # Verify retention_expires_at is NOW() + 10 years
  </verify>
  <done>
    PostgreSQL trigger automatically logs all mutations on 10 tenant-scoped tables with full context (action_type, justification, IP, session, user, old/new data).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create audit context utility for application code</name>
  <files>
    src/data-access/audit-context.ts
  </files>
  <action>
    Create utility to set audit context before mutations:

    **Audit context setter (src/data-access/audit-context.ts):**
    ```typescript
    import 'server-only';
    import { PrismaClient } from '@prisma/client';

    /**
     * Set audit context for the current transaction.
     * Must be called WITHIN a Prisma $transaction, BEFORE the mutation.
     *
     * The PostgreSQL trigger function reads these settings to populate
     * audit_log entries with business context.
     *
     * @param tx - Prisma transaction client
     * @param context - Audit context values
     */
    export async function setAuditContext(
      tx: PrismaClient,
      context: {
        actionType: string;    // e.g., 'observation.created', 'user.role_changed'
        justification?: string; // Required for sensitive operations (DE6)
        ipAddress?: string;
        sessionId?: string;
        userId: string;
        tenantId: string;
      }
    ) {
      await tx.$executeRaw`SELECT set_config('app.current_action', ${context.actionType}, TRUE)`;
      await tx.$executeRaw`SELECT set_config('app.current_justification', ${context.justification ?? ''}, TRUE)`;
      await tx.$executeRaw`SELECT set_config('app.current_ip_address', ${context.ipAddress ?? ''}, TRUE)`;
      await tx.$executeRaw`SELECT set_config('app.current_session_id', ${context.sessionId ?? ''}, TRUE)`;
      await tx.$executeRaw`SELECT set_config('app.current_user_id', ${context.userId}, TRUE)`;
      await tx.$executeRaw`SELECT set_config('app.current_tenant_id', ${context.tenantId}, TRUE)`;
    }
    ```

    **Usage in server actions:**
    ```typescript
    // src/actions/observations.ts
    export async function createObservation(data: ObservationInput) {
      const session = await getRequiredSession();
      const prisma = await prismaForTenant(session.user.tenantId);

      return prisma.$transaction(async (tx) => {
        // Set audit context BEFORE the mutation
        await setAuditContext(tx, {
          actionType: 'observation.created',
          userId: session.user.id,
          tenantId: session.user.tenantId,
          ipAddress: headers().get('x-forwarded-for') ?? '',
          sessionId: session.session.id,
        });

        // The mutation — trigger will automatically log it
        return tx.observation.create({ data: { ... } });
      });
    }
    ```

    **Standard action types (document for consistency):**
    - `observation.created`, `observation.updated`, `observation.status_changed`, `observation.approved`
    - `user.created`, `user.role_changed`, `user.deactivated`
    - `compliance.status_changed`, `compliance.marked_na`
    - `finding.created`, `finding.closed`, `finding.severity_changed`
    - `audit_plan.created`, `audit_plan.updated`
    - `tenant.settings_updated`
    - `evidence.uploaded`

    **Operations requiring justification (DE6):**
    - `finding.closed`
    - `user.role_changed`
    - `compliance.marked_na`
    - `observation.status_changed` (to terminal states)

  </action>
  <verify>
    # Create observation with setAuditContext → audit_log has action_type='observation.created'
    # Close finding with justification → audit_log has justification text
    # Verify all set_config calls use TRUE (transaction-scoped)
  </verify>
  <done>
    Audit context utility sets business-level action metadata before mutations. Trigger reads context to populate audit_log entries.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CAE audit trail viewer page</name>
  <files>
    src/data-access/audit-trail.ts
    src/app/(dashboard)/audit-trail/page.tsx
    src/components/audit-trail/audit-trail-table.tsx
    src/components/audit-trail/audit-trail-filters.tsx
  </files>
  <action>
    Create audit trail viewer accessible by CAE:

    **Audit trail DAL (src/data-access/audit-trail.ts):**
    - `import 'server-only'`
    - `getAuditTrailEntries(session, filters)` — paginated query
    - Filters: entity (tableName), userId, dateRange, actionType
    - Order by: sequenceNumber DESC (most recent first)
    - Join with User table to show user name (not just userId)
    - Explicit WHERE tenantId (belt-and-suspenders, Skeptic S1)
    - Runtime assertion: verify all returned entries have matching tenantId

    **Gap detection query:**
    ```typescript
    export async function detectAuditGaps(session) {
      // Checks for missing sequence numbers
      const gaps = await prisma.$queryRaw`
        SELECT s.i AS missing_sequence
        FROM generate_series(
          (SELECT MIN("sequenceNumber") FROM "AuditLog" WHERE "tenantId" = ${session.user.tenantId}),
          (SELECT MAX("sequenceNumber") FROM "AuditLog" WHERE "tenantId" = ${session.user.tenantId})
        ) AS s(i)
        WHERE NOT EXISTS (
          SELECT 1 FROM "AuditLog"
          WHERE "sequenceNumber" = s.i AND "tenantId" = ${session.user.tenantId}
        )
      `;
      return gaps;
    }
    ```

    **Audit trail page (src/app/(dashboard)/audit-trail/page.tsx):**
    - Server component
    - Require 'audit_trail:read' permission (CAE only via requirePermission)
    - Parse searchParams for filters
    - Fetch audit entries via DAL
    - Render filters + table

    **Audit trail table (src/components/audit-trail/audit-trail-table.tsx):**
    - "use client" component
    - Columns: Sequence #, Date/Time, User, Entity, Action Type, Operation, Details
    - "Details" expands to show old/new data diff
    - Pagination (50 per page)
    - Color coding: sensitive actions highlighted (role changes, closures)

    **Audit trail filters (src/components/audit-trail/audit-trail-filters.tsx):**
    - "use client" component
    - Filter by: Entity (dropdown), User (search), Date range, Action Type (dropdown)
    - Apply filters updates URL searchParams (server-side filtering)
    - "Export to XLSX" button (DE5: with bank name, date, "Confidential" header)

    **XLSX Export:**
    - Server action that generates XLSX using ExcelJS (or defer to Phase 8 if ExcelJS not installed yet)
    - Columns: Sequence #, Date, Time, User Name, Entity, Record ID, Action Type, Operation, Justification, IP Address
    - Header: Bank name, export date, "CONFIDENTIAL - Internal Audit Trail"
    - Human-readable column names (not database column names)

  </action>
  <verify>
    Navigate to /audit-trail as CAE → see list of audit entries
    Filter by entity "Observation" → only observation entries shown
    Filter by date range → entries within range
    Verify sequence numbers are sequential
    Non-CAE user → redirect (cannot access audit trail page)
    Export button generates XLSX with "Confidential" header
  </verify>
  <done>
    CAE audit trail viewer with filters, pagination, sequence-based ordering, gap detection, and XLSX export.
  </done>
</task>

</tasks>

<verification>
**Audit trail validation:**
1. INSERT on any tenant table → audit_log entry created automatically
2. UPDATE on any tenant table → audit_log has oldData and newData as JSONB
3. DELETE on any tenant table → audit_log has oldData
4. action_type reflects business operation (e.g., 'observation.created')
5. justification captured for sensitive operations (role changes, closures)
6. sequenceNumber auto-increments (BIGSERIAL)
7. retentionExpiresAt = created_at + 10 years
8. UPDATE on audit_log fails for aegis_app role (RULE + REVOKE)
9. DELETE on audit_log fails for aegis_app role (RULE + REVOKE)
10. Gap detection query works (delete row as superuser → gap detected)
11. CAE can access /audit-trail and filter by entity/user/date/action
12. XLSX export includes bank name and "Confidential" header
13. Non-CAE users cannot access audit trail page

**Security validation:**

- Trigger fires automatically (no application bypass possible)
- Context set via set_config(TRUE) = transaction-scoped (no cross-request leakage)
- App role can only INSERT + SELECT on audit_log
- Sequence numbers enable gap detection for tampering evidence
  </verification>

<success_criteria>

1. Every data mutation automatically creates audit log entry (no application code opt-in needed)
2. Audit log entries are truly immutable (app role cannot UPDATE or DELETE)
3. CAE can search and filter audit trail with business-level action types
4. 10-year retention configured on every entry
5. Gap detection query identifies missing sequence numbers
   </success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-and-migration/05-05-SUMMARY.md`
</output>
