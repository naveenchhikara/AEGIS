---
phase: 05-foundation-and-migration
plan: 03
type: execute
wave: 2
depends_on: [05-01, 05-02]
files_modified:
  - src/lib/auth.ts
  - src/lib/auth-client.ts
  - src/app/api/auth/[...all]/route.ts
  - src/app/proxy.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(dashboard)/layout.tsx
  - src/components/auth/login-form.tsx
  - src/components/auth/session-warning.tsx
  - src/data-access/session.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - User can sign up with email and password
    - Session persists across browser refresh (verified in incognito)
    - Session cookie is httpOnly, secure (prod), sameSite lax, no persistent expiry
    - Rate limiting active (10 attempts per email per 15 minutes)
    - Account lockout after 5 failures for 30 minutes
    - Concurrent session limit max 2 per user
    - Dashboard layout redirects unauthenticated users with zero content flash
    - proxy.ts checks cookie and redirects before page renders
  artifacts:
    - path: src/lib/auth.ts
      provides: Better Auth server configuration with organization, session, rate limiting plugins
      min_lines: 80
    - path: src/lib/auth-client.ts
      provides: Better Auth client for use in client components
      min_lines: 15
    - path: src/app/api/auth/[...all]/route.ts
      provides: Better Auth API handler (GET, POST exports)
      min_lines: 5
    - path: src/app/proxy.ts
      provides: Next.js 16 proxy with optimistic session cookie check
      min_lines: 20
    - path: src/app/(dashboard)/layout.tsx
      provides: Layout-level session validation, redirect if unauthenticated
      min_lines: 20
    - path: src/data-access/session.ts
      provides: Server-only session helper function used by all DAL modules
      min_lines: 20
  key_links:
    - from: Better Auth
      to: PostgreSQL
      via: Prisma adapter with database sessions
      pattern: "prismaAdapter"
    - from: proxy.ts
      to: Better Auth
      via: Session cookie check
      pattern: "getSessionCookie"
    - from: Dashboard layout
      to: Better Auth
      via: Server-side session validation
      pattern: "auth\\.api\\.getSession"
---

<objective>
Integrate Better Auth for email/password authentication with secure session management, rate limiting, and concurrent session controls.

Purpose: Enable user signup/login with session persistence, secure cookie handling, and protection against credential stuffing — the authentication foundation that all RBAC and data access depends on.

Output: Working auth flow (signup → login → session → logout) with rate limiting, concurrent session limits, and layout-level auth checks.

**Key decisions incorporated:**

- D7: Session cookie not persistent (clears on browser close — critical for shared UCB branch computers)
- D11: Auth rate limiting required (UCB staff use simple passwords)
- D12: Layout-level auth check (zero content flash for unauthenticated users)
- S3: Cookie security settings (httpOnly, secure, sameSite lax, 30min idle + 8hr absolute)
- S7: Rate limiting (10 attempts/15min per email, 30min lockout after 5 failures)
- S8: Concurrent session limit (max 2 per user)
- SA: Session timeout UX (5-minute warning toast)
- SB: Layout-level auth check in (dashboard)/layout.tsx
  </objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Better Auth and configure server/client instances</name>
  <files>
    package.json
    src/lib/auth.ts
    src/lib/auth-client.ts
    src/app/api/auth/[...all]/route.ts
  </files>
  <action>
    Install Better Auth and configure authentication:

    **Install packages:**
    ```bash
    pnpm add better-auth
    ```

    **Server auth config (src/lib/auth.ts):**
    - Use `betterAuth()` with Prisma adapter connected to DATABASE_URL
    - Configure email/password provider
    - Enable organization plugin (for multi-tenancy — maps to our Tenant model)
    - Configure session settings:
      - Cookie: `httpOnly: true`, `secure: process.env.NODE_ENV === 'production'`, `sameSite: 'lax'`
      - Session cookie must NOT have `maxAge` or `expires` (session cookie — clears on browser close, Decision D7)
      - Idle timeout: 30 minutes (`maxAge` for session record, not cookie)
      - Absolute timeout: 8 hours
    - Rate limiting plugin: 10 attempts per email per 15 minutes, 30 minute lockout after 5 consecutive failures (Skeptic S7)
    - Session management: `maximumActiveSessions: 2` (Skeptic S8)
    - Store last login metadata: IP address, timestamp, user agent
    - Force logout all sessions on password change
    - `secret`: from `process.env.BETTER_AUTH_SECRET`
    - `baseURL`: from `process.env.BETTER_AUTH_URL`

    **IMPORTANT:** Check Better Auth latest docs (via context7 MCP) for correct API. The framework updates frequently — do NOT guess config options.

    **Client auth config (src/lib/auth-client.ts):**
    - Export `authClient` using `createAuthClient()` with matching plugins (organization)
    - Export typed hooks: `useSession`, `signIn`, `signUp`, `signOut`

    **API route handler (src/app/api/auth/[...all]/route.ts):**
    - Use `toNextJsHandler(auth)` to export GET and POST handlers
    - This is the standard Better Auth pattern for Next.js

    **CRITICAL:** Verify Better Auth docs for:
    - Correct Prisma adapter import path
    - Session configuration options (idle vs absolute timeout)
    - Rate limiting plugin name and configuration
    - Organization plugin setup

  </action>
  <verify>
    pnpm build (no TypeScript errors)
    # Check auth API route responds:
    curl -s http://localhost:3000/api/auth/ok | grep ok
  </verify>
  <done>
    Better Auth server and client configured with Prisma adapter, session settings, rate limiting, and concurrent session limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create login/signup page and auth form components</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/components/auth/login-form.tsx
    src/components/auth/signup-form.tsx
  </files>
  <action>
    Create authentication UI:

    **Login page (src/app/(auth)/login/page.tsx):**
    - Server component that checks session — if already authenticated, redirect to /dashboard
    - Render LoginForm client component
    - Clean, centered card layout using shadcn/ui Card component
    - AEGIS branding (logo/name at top)
    - Tab toggle between "Login" and "Sign Up"

    **Login form (src/components/auth/login-form.tsx):**
    - "use client" component
    - Email + password fields using shadcn/ui Input, Label, Button
    - Form validation with error display
    - Loading state on submit button
    - Call `authClient.signIn.email()` on submit
    - Handle rate limiting errors (display "Too many attempts" message)
    - Handle account lockout errors
    - Redirect to /dashboard on success
    - Display last login metadata after successful login (toast notification)

    **Signup form (src/components/auth/signup-form.tsx):**
    - "use client" component
    - Name, email, password, confirm password fields
    - Password strength indicator (min 8 chars, 1 uppercase, 1 number)
    - Call `authClient.signUp.email()` on submit
    - Handle errors (duplicate email, weak password)
    - Redirect to /dashboard on success (or onboarding if new tenant)

    **Use existing shadcn/ui components:** Card, CardHeader, CardTitle, CardDescription, CardContent, Input, Label, Button, Tabs, TabsContent, TabsList, TabsTrigger

  </action>
  <verify>
    Navigate to /login — see login form
    Submit with valid credentials — redirect to /dashboard
    Submit with invalid credentials — see error message
    5 failed attempts — see lockout message
  </verify>
  <done>
    Login and signup forms working with proper error handling, rate limiting display, and redirect behavior.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement proxy.ts and layout-level auth guard</name>
  <files>
    src/app/proxy.ts
    src/app/(dashboard)/layout.tsx
  </files>
  <action>
    Implement two-layer authentication protection:

    **Layer 1 — proxy.ts (optimistic, fast):**
    - Check for Better Auth session cookie presence
    - If no cookie and path starts with /(dashboard), redirect to /login
    - If cookie exists, pass through (no DB call — proxy must be fast)
    - Do NOT validate the session in proxy — that's the layout's job
    - Import `getSessionCookie` from Better Auth cookies utility

    **IMPORTANT:** Check Better Auth latest docs for the correct proxy.ts / middleware pattern for Next.js 16. Next.js 16 uses proxy.ts, NOT middleware.ts.

    **Layer 2 — (dashboard)/layout.tsx (authoritative, secure):**
    - Server component
    - Call `auth.api.getSession({ headers: await headers() })` to validate session
    - If no valid session → `redirect('/login')` (this happens BEFORE any children render → zero content flash, Decision D12)
    - If valid session → render children wrapped in SidebarProvider + AppSidebar
    - Pass session data to context/provider for child components

    **Modify existing layout.tsx:**
    - The current layout.tsx has SidebarProvider > AppSidebar + SidebarInset structure
    - ADD session validation at the top, BEFORE the return statement
    - KEEP the existing layout structure (SidebarProvider, AppSidebar, TopBar, main)
    - PASS session data down to AppSidebar (for user info display)

    **CRITICAL:** The session check in layout.tsx is the TRUE security boundary. proxy.ts is just UX optimization (prevents flash). A user with a stale/expired cookie will pass proxy.ts but fail layout.tsx validation.

  </action>
  <verify>
    # Without session cookie:
    Access /dashboard → redirected to /login (no dashboard content visible)
    # With valid session:
    Access /dashboard → dashboard renders normally
    # With expired cookie:
    Access /dashboard → proxy lets through, layout catches → redirect to /login
  </verify>
  <done>
    Two-layer auth protection: proxy.ts for optimistic redirect, layout.tsx for authoritative session validation. Zero content flash for unauthenticated users.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create session helper for Data Access Layer</name>
  <files>
    src/data-access/session.ts
  </files>
  <action>
    Create centralized session validation helper:

    **Session helper (src/data-access/session.ts):**
    ```typescript
    import 'server-only';
    import { auth } from '@/lib/auth';
    import { headers } from 'next/headers';
    import { redirect } from 'next/navigation';

    /**
     * Get authenticated session or redirect to login.
     * MUST be used in all DAL functions and server actions.
     *
     * CRITICAL SECURITY (Skeptic S2):
     * - tenantId MUST come from this session ONLY
     * - NEVER accept tenantId from URL params, request body, or query string
     * - DAL functions accept the session object returned by this function
     */
    export async function getRequiredSession() {
      const session = await auth.api.getSession({
        headers: await headers(),
      });

      if (!session) {
        redirect('/login');
      }

      return session;
    }

    /**
     * Get session without redirect (for optional auth checks).
     * Returns null if not authenticated.
     */
    export async function getOptionalSession() {
      return auth.api.getSession({
        headers: await headers(),
      });
    }
    ```

    **IMPORTANT:** This file has `import 'server-only'` at the top to prevent client-side import.

    The `getRequiredSession()` function is the SINGLE SOURCE of tenantId for all DAL functions. All DAL functions should call this, extract tenantId from the returned session, and use it for:
    1. `prismaForTenant(session.user.tenantId)` — RLS isolation
    2. Explicit `WHERE tenantId` clauses — belt-and-suspenders (Skeptic S1)
    3. Runtime assertion — verify returned data has matching tenantId (Skeptic S1)

  </action>
  <verify>
    pnpm build (no TypeScript errors, server-only directive works)
    # Import in a server component → works
    # Import in a client component → build error (server-only prevents it)
  </verify>
  <done>
    Session helper created with server-only directive. All DAL functions will use getRequiredSession() as the single source of tenantId.
  </done>
</task>

<task type="auto">
  <name>Task 5: Session timeout warning and .env updates</name>
  <files>
    src/components/auth/session-warning.tsx
    .env.example
    .env
  </files>
  <action>
    Create session timeout UX and update environment variables:

    **Session warning toast (src/components/auth/session-warning.tsx):**
    - "use client" component
    - Check session expiry periodically (every 60 seconds)
    - When session expires in < 5 minutes, show warning toast (Recommendation SA)
    - Toast message: "Your session expires in X minutes. Save your work."
    - Auto-save current form data to localStorage before session expiry
    - On session expired: redirect to /login with ?expired=true query param
    - Login page shows "Session expired" message when expired=true

    **Mount SessionWarning in dashboard layout:**
    - Add `<SessionWarning />` inside the dashboard layout
    - It runs client-side, checking the session cookie/token expiry

    **Update .env.example with auth variables:**
    Add these to existing .env.example:
    ```
    # Authentication (Better Auth)
    BETTER_AUTH_SECRET=CHANGE_ME_GENERATE_WITH_openssl_rand_base64_32
    BETTER_AUTH_URL=http://localhost:3000
    ```

    **Update .env with local dev values:**
    Add these to existing .env:
    ```
    # Authentication (Better Auth)
    BETTER_AUTH_SECRET=dev-secret-not-for-production-use-only
    BETTER_AUTH_URL=http://localhost:3000
    ```

    **IMPORTANT:** .env is gitignored. .env.example uses CHANGE_ME placeholders.

  </action>
  <verify>
    # Session warning appears 5 minutes before timeout
    # Session expired → user redirected to /login with message
    # .env.example has CHANGE_ME placeholder for BETTER_AUTH_SECRET
    grep "CHANGE_ME" .env.example | wc -l (should be 4+)
  </verify>
  <done>
    Session timeout UX with warning toast and auto-save. Environment variables updated for Better Auth.
  </done>
</task>

</tasks>

<verification>
**Authentication flow validation:**
1. User can sign up with email/password → user record created in database
2. User can login with correct credentials → session created, redirected to /dashboard
3. Session persists across browser refresh (test in incognito)
4. Session cookie is httpOnly, no max-age (session cookie), sameSite lax
5. 11th login attempt within 15 minutes → rate limited (HTTP 429)
6. 6th consecutive failure → account locked for 30 minutes
7. Login on 3rd browser → oldest session invalidated (max 2 concurrent)
8. Last login metadata displayed (IP, timestamp)
9. Access /dashboard without cookie → redirect to /login (proxy.ts)
10. Access /dashboard with expired cookie → redirect to /login (layout.tsx)
11. No dashboard HTML in response when unauthenticated (zero content flash)
12. Password change → all other sessions invalidated
13. Session warning toast appears 5 minutes before idle timeout
14. Better Auth + next-intl cookies coexist (language persists through auth flow)

**Security validation (Skeptic review items):**

- Cookie: httpOnly ✓, secure (prod) ✓, sameSite lax ✓, session-only ✓
- Rate limiting: 10/15min ✓, lockout 30min after 5 failures ✓
- Concurrent sessions: max 2 ✓
- tenantId from session only (session.ts enforces this pattern) ✓
  </verification>

<success_criteria>

1. User can complete full auth flow: signup → login → browse dashboard → logout
2. Rate limiting prevents brute force (11th attempt blocked)
3. Session persists across refresh but clears on browser close
4. No content flash on /dashboard for unauthenticated users
5. Session helper established as single source of tenantId
   </success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-and-migration/05-03-SUMMARY.md`
</output>
