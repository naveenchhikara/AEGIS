---
phase: 09-dashboards
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data-access/dashboard.ts
autonomous: true

must_haves:
  truths:
    - "getDashboardData orchestrator fetches only data for widgets the user will see"
    - "All query functions use prismaForTenant with explicit WHERE tenantId"
    - "Health score queries use PostgreSQL views (v_compliance_summary, v_observation_severity, v_audit_coverage_branch)"
    - "User-scoped queries for my-observations, my-reviews, my-engagements filter by userId"
    - "Trend queries return last 4-6 quarters of data for chart rendering"
    - "import 'server-only' at top of file"
  artifacts:
    - path: src/data-access/dashboard.ts
      provides: All dashboard data query functions with role-based and widget-based filtering
      min_lines: 120
      contains: "getDashboardData"
  key_links:
    - from: dashboard.ts
      to: src/lib/prisma.ts
      via: prismaForTenant for tenant-scoped queries
      pattern: "prismaForTenant"
    - from: dashboard.ts
      to: PostgreSQL views
      via: Raw SQL queries against v_compliance_summary, v_observation_aging, etc.
      pattern: "$queryRaw"
    - from: dashboard.ts
      to: src/lib/fiscal-year.ts
      via: Uses FY utilities for date range filtering
      pattern: "getCurrentFiscalYear"
---

<objective>
Create the dashboard data access layer with all query functions needed by dashboard widgets.

Purpose: This DAL provides the server-side data fetching for all 5 role dashboards. It uses PostgreSQL views for aggregation queries and Prisma for user-scoped queries. The orchestrator function only fetches data needed by the user's widget configuration, avoiding unnecessary queries.

Output: 1 comprehensive DAL file with ~15 query functions.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-dashboards/09-PLAN.md
@src/lib/prisma.ts
@src/lib/fiscal-year.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create aggregation query functions</name>
  <files>src/data-access/dashboard.ts</files>
  <action>
**dashboard.ts — aggregate query functions:**

`import "server-only"` at top.

**1. getHealthScore(db, tenantId):**

- Use `$queryRaw` to call `fn_dashboard_health_score(tenantId)`
- Returns numeric score (0-100)
- Handle null (new tenant) → return 0

**2. getComplianceSummary(db, tenantId):**

- Query `v_compliance_summary` WHERE tenant_id = tenantId
- Returns `{ total, compliant, partial, nonCompliant, pending, percentage }`
- Handle empty → all zeros

**3. getObservationSeverity(db, tenantId):**

- Query `v_observation_severity` WHERE tenant_id = tenantId
- Returns `{ total, totalOpen, criticalOpen, highOpen, mediumOpen, lowOpen, closed }`

**4. getObservationAging(db, tenantId):**

- Query `v_observation_aging` WHERE tenant_id = tenantId
- Returns `{ totalOpen, current, bucket030, bucket3160, bucket6190, bucket90Plus }`

**5. getAuditCoverage(db, tenantId):**

- Query `v_audit_coverage_branch` WHERE tenant_id = tenantId
- Returns `{ branches: Array<{ id, name, completedEngagements, isCovered }>, coveredCount, totalCount, percentage }`

**6. getAuditorWorkload(db, tenantId):**

- Query `v_auditor_workload` WHERE tenant_id = tenantId
- Returns array of `{ auditorId, auditorName, totalAssigned, openCount, highCriticalOpen }`
  </action>
  <verify>Run `pnpm build`. Verify all 6 aggregate functions use $queryRaw with parameterized queries. Verify null handling for new tenants.</verify>
  <done>6 aggregate query functions using PostgreSQL views for fast dashboard data retrieval.</done>
  </task>

<task type="auto">
  <name>Task 2: Create user-scoped and trend query functions + orchestrator</name>
  <files>src/data-access/dashboard.ts</files>
  <action>
**User-scoped queries (Prisma, not raw SQL):**

**7. getMyAssignedObservations(db, userId, tenantId):**

- Query Observation WHERE assignedToId = userId AND status != CLOSED, tenantId
- Include severity, branch name, due date
- Order by dueDate ASC (closest deadline first)
- Limit 10

**8. getMyPendingReviews(db, userId, tenantId):**

- Query Observation WHERE status = SUBMITTED AND engagementCreatedById = userId, tenantId
- Observations awaiting manager review
- Limit 10

**9. getMyEngagementProgress(db, userId, tenantId):**

- Query AuditEngagement WHERE assignedToId includes userId
- Include observation count, completed count, status
- Current FY only (use getFiscalYearDateRange)

**Trend queries (for charts):**

**10. getSeverityTrend(db, tenantId, quarters):**

- Observation count by severity per quarter for last 4-6 quarters
- Group by fiscal quarter using fn_extract_fiscal_year
- Returns time-series data for line/area charts

**11. getComplianceTrend(db, tenantId, quarters):**

- Compliance percentage over time (if historical snapshots exist)
- Fallback: current compliance only with note "Trend data available after first quarter"

**12. getBranchRiskData(db, tenantId):**

- Branches ranked by open observation count + severity-weighted score
- Returns branch risk heatmap data

**13. getBoardReportReadiness(db, tenantId):**

- Check data availability for each board report section
- Returns checklist: `{ section: string; isReady: boolean; missingData?: string }[]`

**14. getRegulatoryCalendar(db, tenantId):**

- ComplianceRequirement sorted by nextReviewDate (upcoming deadlines)
- Filter next 30 days
- Returns `{ id, requirement, category, nextReviewDate }[]`

**15. getDashboardData(session, widgetConfig):**

Orchestrator function:

- Takes session (for user/tenant context) and widgetConfig (array of widget IDs)
- Fetches only data needed by the configured widgets
- Uses `Promise.all` for parallel data fetching where possible
- Returns `Record<string, unknown>` keyed by widget data key
  </action>
  <verify>Run `pnpm build`. Verify user-scoped queries filter by userId AND tenantId. Verify orchestrator only fetches data for configured widgets. Verify trend queries handle empty data gracefully.</verify>
  <done>User-scoped, trend, and role-specific query functions. getDashboardData orchestrator fetches only what each role needs.</done>
  </task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. getDashboardData orchestrator conditionally fetches based on widgetConfig
3. All aggregate queries use $queryRaw against PostgreSQL views
4. User-scoped queries filter by userId AND tenantId (belt-and-suspenders)
5. Trend queries return quarterly data for chart rendering
6. Empty data handled gracefully (zeros, empty arrays — no errors)
7. `import "server-only"` prevents client-side import
</verification>

<success_criteria>

- Dashboard data access layer provides all data for 5 role dashboards (DASH-01 through DASH-05)
- Orchestrator fetches only needed data (efficient for each role)
- PostgreSQL views used for aggregate queries (DASH-06)
- User-scoped queries maintain tenant isolation
- Trend queries support chart rendering with quarterly granularity
  </success_criteria>

<output>
After completion, create `.planning/phases/09-dashboards/09-02-SUMMARY.md`
</output>
