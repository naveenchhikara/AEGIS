---
phase: 12-dashboard-data-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/jobs/snapshot-metrics.ts
  - src/jobs/index.ts
  - src/lib/job-queue.ts
  - src/data-access/dashboard.ts
  - src/data-access/reports.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Daily snapshot job captures health score, compliance, and severity metrics for all tenants"
    - "getSeverityTrend reads from DashboardSnapshot table instead of Observation.createdAt"
    - "getComplianceTrend reads from DashboardSnapshot table with historical data points"
    - "Board report repeat findings section queries observations with repeatOfId populated"
  artifacts:
    - path: "src/jobs/snapshot-metrics.ts"
      provides: "Daily metrics snapshot capture job"
      exports: ["captureMetricsSnapshot"]
    - path: "src/jobs/index.ts"
      provides: "Snapshot job registration with pg-boss"
      contains: "SNAPSHOT_METRICS"
    - path: "src/lib/job-queue.ts"
      provides: "Snapshot job name and cron schedule"
      contains: "snapshot-metrics"
    - path: "src/data-access/dashboard.ts"
      provides: "Updated trend queries reading from DashboardSnapshot"
      contains: "dashboardSnapshot.findMany"
    - path: "src/data-access/reports.ts"
      provides: "Repeat findings query using repeatOfId FK"
      contains: "repeatOfId"
  key_links:
    - from: "src/jobs/snapshot-metrics.ts"
      to: "src/data-access/dashboard.ts"
      via: "imports getHealthScore, getComplianceSummary, getObservationSeverity"
      pattern: "import.*getHealthScore.*dashboard"
    - from: "src/jobs/snapshot-metrics.ts"
      to: "prisma/schema.prisma (DashboardSnapshot)"
      via: "db.dashboardSnapshot.create"
      pattern: "dashboardSnapshot\\.create"
    - from: "src/data-access/dashboard.ts (getSeverityTrend)"
      to: "prisma/schema.prisma (DashboardSnapshot)"
      via: "db.dashboardSnapshot.findMany"
      pattern: "dashboardSnapshot\\.findMany"
    - from: "src/data-access/reports.ts (repeatFindings)"
      to: "prisma/schema.prisma (Observation.repeatOfId)"
      via: "observation.findMany where repeatOfId not null"
      pattern: "repeatOfId.*not.*null"
---

<objective>
Create the daily snapshot capture job, update trend queries to read from DashboardSnapshot instead of Observation.createdAt, and wire the repeat findings board report section to query real data via repeatOfId.

Purpose: Closes Phase 9 tech debt (trend widgets returning null/computed-from-createdAt) and Phase 8 tech debt (repeat findings board report empty). After this plan, all four Phase 12 success criteria are satisfied.
Output: Working snapshot job, real trend data queries, and repeat findings in board reports.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-dashboard-data-pipeline/12-RESEARCH.md
@.planning/phases/12-dashboard-data-pipeline/12-01-SUMMARY.md
@src/jobs/index.ts
@src/lib/job-queue.ts
@src/data-access/dashboard.ts
@src/data-access/reports.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snapshot-metrics job and register with pg-boss</name>
  <files>
    src/jobs/snapshot-metrics.ts
    src/jobs/index.ts
    src/lib/job-queue.ts
  </files>
  <action>
  **1. Create `src/jobs/snapshot-metrics.ts`** (NEW file):

```typescript
import "server-only";
import { prismaForTenant } from "@/lib/prisma";
import {
  getHealthScore,
  getComplianceSummary,
  getObservationSeverity,
} from "@/data-access/dashboard";

/**
 * Daily snapshot capture job.
 * Runs at 01:00 IST (19:30 UTC) via pg-boss cron.
 * Captures health score, compliance summary, and severity breakdown
 * for each onboarded tenant into the DashboardSnapshot table.
 */
export async function captureMetricsSnapshot(): Promise<void> {
  console.log("[snapshot-metrics] Starting daily capture");

  // Use dynamic import to get root Prisma (avoids server-only circular)
  const { PrismaClient } = await import("@prisma/client");
  const rootPrisma = new PrismaClient();

  try {
    const tenants = await rootPrisma.tenant.findMany({
      where: { onboardingCompleted: true },
      select: { id: true, name: true },
    });

    console.log(`[snapshot-metrics] Found ${tenants.length} tenants`);

    // Process tenants in batches of 10 to avoid connection pool exhaustion
    const BATCH_SIZE = 10;
    let captured = 0;

    for (let i = 0; i < tenants.length; i += BATCH_SIZE) {
      const batch = tenants.slice(i, i + BATCH_SIZE);
      await Promise.all(
        batch.map(async (tenant) => {
          try {
            const db = prismaForTenant(tenant.id);
            const [health, compliance, severity] = await Promise.all([
              getHealthScore(db, tenant.id),
              getComplianceSummary(db, tenant.id),
              getObservationSeverity(db, tenant.id),
            ]);

            await db.dashboardSnapshot.create({
              data: {
                tenantId: tenant.id,
                metrics: {
                  healthScore: health.score,
                  compliance: {
                    total: compliance.total,
                    compliant: compliance.compliant,
                    partial: compliance.partial,
                    nonCompliant: compliance.nonCompliant,
                    pending: compliance.pending,
                    percentage: compliance.percentage,
                  },
                  severity: {
                    total: severity.total,
                    totalOpen: severity.totalOpen,
                    criticalOpen: severity.criticalOpen,
                    highOpen: severity.highOpen,
                    mediumOpen: severity.mediumOpen,
                    lowOpen: severity.lowOpen,
                    closed: severity.closed,
                  },
                },
              },
            });
            captured++;
            console.log(`[snapshot-metrics] Captured for ${tenant.name}`);
          } catch (error) {
            console.error(
              `[snapshot-metrics] Failed for ${tenant.name}:`,
              error,
            );
            // Continue with next tenant — don't fail entire batch
          }
        }),
      );
    }

    console.log(
      `[snapshot-metrics] Daily capture complete: ${captured}/${tenants.length} tenants`,
    );
  } finally {
    await rootPrisma.$disconnect();
  }
}
```

**Important notes:**

- Uses dynamic import for PrismaClient to get root (non-tenant-scoped) access for listing tenants
- Uses `prismaForTenant()` for each tenant's snapshot capture (respects RLS)
- Batch size of 10 prevents connection pool exhaustion
- try/catch per tenant — one failure doesn't stop other tenants
- Stores full compliance and severity objects (not just totals) for future widget flexibility

**2. Update `src/lib/job-queue.ts`** — add snapshot job name and schedule:

Add to `JOB_NAMES`:

```typescript
SNAPSHOT_METRICS: "snapshot-metrics",
```

Add queue creation (after GENERATE_BOARD_REPORT line):

```typescript
await queue.createQueue(JOB_NAMES.SNAPSHOT_METRICS, QUEUE_OPTIONS);
```

Add schedule (after the weekly digest schedule line):

```typescript
await queue.schedule(JOB_NAMES.SNAPSHOT_METRICS, "30 19 * * *"); // daily 19:30 UTC = 01:00 IST
```

**3. Update `src/jobs/index.ts`** — register snapshot handler:

Add import at top:

```typescript
import { captureMetricsSnapshot } from "./snapshot-metrics";
```

Add to JOBS constant:

```typescript
SNAPSHOT_METRICS: "snapshot-metrics",
```

Add handler registration (after the board report handler):

```typescript
// Daily metrics snapshot for dashboard trends (01:00 IST)
await boss.work(JOBS.SNAPSHOT_METRICS, async () => {
  await captureMetricsSnapshot();
});
```

  </action>
  <verify>
  1. `pnpm build` passes — no TypeScript errors
  2. `src/jobs/snapshot-metrics.ts` exists and exports `captureMetricsSnapshot`
  3. `src/lib/job-queue.ts` contains `SNAPSHOT_METRICS` in JOB_NAMES and `"30 19 * * *"` cron
  4. `src/jobs/index.ts` imports and registers the snapshot handler
  5. Grep for `dashboardSnapshot.create` in snapshot-metrics.ts — writes to DashboardSnapshot table
  </verify>
  <done>
  Daily snapshot job runs at 01:00 IST, captures health score + compliance + severity metrics for all onboarded tenants into DashboardSnapshot table. Registered with pg-boss cron scheduler.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update trend queries and repeat findings to use real data</name>
  <files>
    src/data-access/dashboard.ts
    src/data-access/reports.ts
  </files>
  <action>
  **1. Update `getSeverityTrend()` in `src/data-access/dashboard.ts`** (lines 718-774):

Replace the entire function body. Instead of querying `Observation.createdAt` and counting by severity, read from `DashboardSnapshot`:

```typescript
export async function getSeverityTrend(
  db: ReturnType<typeof prismaForTenant>,
  tenantId: string,
  quartersBack: number = 6,
): Promise<SeverityTrendPoint[]> {
  // Read from DashboardSnapshot instead of computing from Observation.createdAt
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - quartersBack * 3);

  const snapshots = await db.dashboardSnapshot.findMany({
    where: {
      tenantId,
      capturedAt: { gte: sixMonthsAgo },
    },
    orderBy: { capturedAt: "asc" },
    select: {
      capturedAt: true,
      metrics: true,
    },
  });

  if (snapshots.length === 0) {
    return []; // Widget shows "available after first quarter" message
  }

  // Group snapshots by fiscal quarter, take latest snapshot per quarter
  const buckets = new Map<string, SeverityTrendPoint>();

  for (const snap of snapshots) {
    const date = new Date(snap.capturedAt);
    const month = date.getMonth();
    const calYear = date.getFullYear();
    const fyYear = month < 3 ? calYear - 1 : calYear;

    let quarter: string;
    if (month >= 3 && month <= 5) quarter = "Q1";
    else if (month >= 6 && month <= 8) quarter = "Q2";
    else if (month >= 9 && month <= 11) quarter = "Q3";
    else quarter = "Q4";

    const key = `${fyYear}-${quarter}`;
    const metrics = snap.metrics as any;

    // Latest snapshot per quarter overwrites earlier ones
    buckets.set(key, {
      quarter,
      year: fyYear,
      critical: metrics?.severity?.criticalOpen ?? 0,
      high: metrics?.severity?.highOpen ?? 0,
      medium: metrics?.severity?.mediumOpen ?? 0,
      low: metrics?.severity?.lowOpen ?? 0,
    });
  }

  const sorted = Array.from(buckets.values()).sort((a, b) => {
    if (a.year !== b.year) return a.year - b.year;
    const qOrder: Record<string, number> = { Q1: 1, Q2: 2, Q3: 3, Q4: 4 };
    return (qOrder[a.quarter] ?? 0) - (qOrder[b.quarter] ?? 0);
  });

  return sorted.slice(-quartersBack);
}
```

**2. Update `getComplianceTrend()` in `src/data-access/dashboard.ts`** (lines 778-792):

Replace the entire function. Instead of returning only current compliance percentage with a "trend data available after first quarterly review" note, return historical data points:

```typescript
export async function getComplianceTrend(
  db: ReturnType<typeof prismaForTenant>,
  tenantId: string,
): Promise<{
  current: number;
  trend: { date: string; percentage: number }[];
  note?: string;
}> {
  // Get current compliance
  const summary = await getComplianceSummary(db, tenantId);

  // Get historical snapshots for trend line (last 6 months)
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);

  const snapshots = await db.dashboardSnapshot.findMany({
    where: {
      tenantId,
      capturedAt: { gte: sixMonthsAgo },
    },
    orderBy: { capturedAt: "asc" },
    select: {
      capturedAt: true,
      metrics: true,
    },
  });

  const trend = snapshots.map((snap) => {
    const metrics = snap.metrics as any;
    return {
      date: snap.capturedAt.toISOString().slice(0, 10), // YYYY-MM-DD
      percentage: metrics?.compliance?.percentage ?? 0,
    };
  });

  return {
    current: summary.percentage,
    trend,
    note:
      summary.total === 0
        ? "Set up compliance registry to begin tracking"
        : trend.length === 0
          ? "Trend data available after first daily snapshot"
          : undefined,
  };
}
```

**Important:** The return type changes from `{ current: number; note?: string }` to `{ current: number; trend: { date: string; percentage: number }[]; note?: string }`. Update the `DashboardData` interface's `complianceTrend` field to match:

```typescript
complianceTrend?: { current: number; trend: { date: string; percentage: number }[]; note?: string };
```

**3. Update repeat findings in `src/data-access/reports.ts`** (lines 224-234):

Replace the placeholder empty array with a real query using `repeatOfId`:

```typescript
// ─── Repeat Findings ───────────────────────────────────────────────
const repeatObservations = await db.observation.findMany({
  where: {
    tenantId,
    repeatOfId: { not: null },
  },
  include: {
    repeatOf: {
      select: {
        createdAt: true,
        severity: true,
      },
    },
  },
  orderBy: { createdAt: "desc" },
});

const repeatFindings: {
  title: string;
  originalDate: string;
  occurrenceCount: number;
  currentSeverity: string;
  previousSeverity: string;
  status: string;
}[] = repeatObservations.map((o: any) => ({
  title: o.title,
  originalDate: o.repeatOf?.createdAt
    ? formatDateIndian(o.repeatOf.createdAt)
    : "Unknown",
  occurrenceCount: 2, // Current + original (simple 2-level relation)
  currentSeverity: o.severity,
  previousSeverity: o.repeatOf?.severity ?? o.severity,
  status: o.status,
}));
```

**Key notes:**

- `formatDateIndian` is already imported/available in reports.ts (check existing imports, or use the `formatDate` from `@/lib/utils` — whatever the file already uses for date formatting)
- occurrenceCount is 2 (current + original) — full ancestry tree counting deferred per research recommendation
- Results sorted by createdAt desc (most recent repeat findings first)
- When no observations have repeatOfId set, returns empty array (same as before, but now from real query)
  </action>
  <verify>

1. `pnpm build` passes — no TypeScript errors
2. Grep `dashboard.ts` for `dashboardSnapshot.findMany` — appears in both getSeverityTrend and getComplianceTrend
3. Grep `dashboard.ts` for `Observation.createdAt` in getSeverityTrend — should NOT appear (replaced with snapshot query)
4. Grep `reports.ts` for `repeatOfId` — appears in the repeat findings query
5. Grep `reports.ts` for "not yet implemented" — should NOT appear (placeholder removed)
6. The ComplianceTrend type in DashboardData interface includes `trend` array
   </verify>
   <done>
   getSeverityTrend reads from DashboardSnapshot (not Observation.createdAt). getComplianceTrend returns historical trend data from snapshots. Board report repeat findings section queries observations with repeatOfId populated. All three Phase 9/8 tech debt items resolved.
   </done>
   </task>

</tasks>

<verification>
1. `pnpm build` passes with no TypeScript errors
2. Snapshot job exists at `src/jobs/snapshot-metrics.ts` and is registered in `src/lib/job-queue.ts` with daily cron
3. `getSeverityTrend()` queries `db.dashboardSnapshot.findMany` (not `db.observation.findMany`)
4. `getComplianceTrend()` returns `trend` array from DashboardSnapshot history
5. `reports.ts` repeat findings query uses `repeatOfId: { not: null }` instead of empty array
6. No "not yet implemented" or "available after first quarterly review" placeholder comments remain in the modified functions
</verification>

<success_criteria>

- Daily snapshot job registered with pg-boss at `30 19 * * *` (01:00 IST)
- Snapshot captures healthScore, compliance summary, and severity breakdown per tenant
- getSeverityTrend reads quarterly data from DashboardSnapshot table
- getComplianceTrend returns historical trend points from DashboardSnapshot
- Board report repeat findings section renders real data from repeatOfId relation
- `pnpm build` succeeds
  </success_criteria>

<output>
After completion, create `.planning/phases/12-dashboard-data-pipeline/12-02-SUMMARY.md`
</output>
