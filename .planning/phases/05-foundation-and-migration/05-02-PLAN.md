---
phase: 05-foundation-and-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/seed.ts
  - prisma/migrations/add_rls_policies.sql
  - prisma/migrations/add_audit_log_rules.sql
  - scripts/test-tenant-isolation.ts
  - package.json
  - src/lib/prisma.ts
autonomous: true

must_haves:
  truths:
    - All tables have tenant_id column with UUID type
    - RLS policies enforce tenant isolation on every table
    - FORCE ROW LEVEL SECURITY enabled on ALL 10 tenant-scoped tables (not just 4)
    - User model has roles Role[] (array, not single enum) for multi-role support
    - audit_log table has sequence_number, action_type, justification, ip_address, session_id, retention_expires_at
    - UPDATE and DELETE on audit_log are blocked by PostgreSQL rules AND revoked from aegis_app role
    - Dedicated aegis_app PostgreSQL role (not superuser) for application connections
    - Tenant model includes DAKSH/PCA/NABARD/scheduledBankStatus fields
    - Financial quarter enum uses Indian fiscal year (Q1=Apr-Jun)
  artifacts:
    - path: prisma/schema.prisma
      provides: Complete database schema with tenant isolation and multi-role support
      min_lines: 300
      contains: "roles Role[]"
    - path: src/lib/prisma.ts
      provides: Prisma client with RLS extension
      exports: ["prisma", "prismaForTenant"]
    - path: prisma/seed.ts
      provides: Demo data seeding script for development
      min_lines: 100
    - path: scripts/test-tenant-isolation.ts
      provides: Tenant isolation test script that generates PDF certificate
      min_lines: 50
  key_links:
    - from: prismaForTenant function
      to: PostgreSQL set_config
      via: Transaction-scoped tenant context
      pattern: "set_config\\('app.current_tenant_id'"
    - from: All tenant-scoped models
      to: Tenant model
      via: Foreign key with onDelete Cascade
      pattern: "tenant_id.*@relation.*onDelete: Cascade"
---

<objective>
Define complete PostgreSQL database schema with Prisma ORM, implement Row-Level Security policies for multi-tenant isolation, configure Prisma Client Extensions, and create the audit_log infrastructure with immutability guarantees.

Purpose: Establish the data model foundation with built-in multi-tenancy security and regulatory-grade audit trail. RLS at database level prevents cross-tenant data leaks even if application code has bugs. Audit log immutability satisfies FNDN-07 (RBI compliance).

Output: Prisma schema with 15+ models, migration files, RLS policies on all tables, FORCE RLS on all 10 tenant-scoped tables, dedicated app role, immutable audit_log with sequence numbers, and Prisma client singleton with tenant-scoped extension.

**Key decisions incorporated:**

- D8: FORCE RLS on ALL 10 tables (Skeptic S5)
- D13: Multi-role users via roles Role[] (UCB Domain Expert DE1)
- D14: 10-year audit trail retention (PMLA — DE3)
- D15: Business action_type + justification in audit_log (DE5, DE6)
- D16: Hardcoded April-March fiscal year (DE7)
- D17: DAKSH/PCA/NABARD fields in Tenant model (DE8)
- D18: Tenant isolation certificate (DE4)
- D20: Permission checks use roles.includes() not role === (UCB Expert impl note)
- D21: DAKSH/PCA fields nullable (UCB Expert impl note)
  </objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prisma schema with multi-tenant models and multi-role users</name>
  <files>
    prisma/schema.prisma
    package.json
  </files>
  <action>
    Initialize Prisma and create schema with multi-tenant architecture:

    **Install dependencies:**
    ```bash
    pnpm add @prisma/client @prisma/adapter-pg pg
    pnpm add -D prisma @types/pg
    ```

    **Create schema.prisma:**

    **Enums (UPDATED per advisory reviews):**
    - Role: AUDITOR, AUDIT_MANAGER, CAE, CCO, CEO, AUDITEE, BOARD_OBSERVER
      - BOARD_OBSERVER is reserved for future use (Decision D17/DE9) — do not build features for it yet
    - Severity: LOW, MEDIUM, HIGH, CRITICAL
    - ObservationStatus: DRAFT, SUBMITTED, REVIEWED, ISSUED, RESPONSE, COMPLIANCE, CLOSED
    - ComplianceStatus: COMPLIANT, PARTIAL, NON_COMPLIANT, PENDING
    - UcbTier: TIER_1, TIER_2, TIER_3, TIER_4
    - PcaStatus: NONE, PCA_1, PCA_2, PCA_3
    - Quarter: Q1_APR_JUN, Q2_JUL_SEP, Q3_OCT_DEC, Q4_JAN_MAR
      - **CRITICAL (D16):** These are INDIAN FINANCIAL YEAR quarters, NOT calendar quarters
    - AuditPlanStatus: PLANNED, IN_PROGRESS, COMPLETED, ON_HOLD, CANCELLED
    - EngagementStatus: PLANNED, IN_PROGRESS, COMPLETED, CANCELLED

    **Core models:**
    - Tenant (id UUID, name, shortName, rbiLicenseNo, tier UcbTier, state, city,
      scheduledBankStatus Boolean @default(false),
      nabardRegistrationNo String?,
      multiStateLicense Boolean @default(false),
      dakshScore Decimal? @db.Decimal(5,2),
      dakshScoreDate DateTime?,
      pcaStatus PcaStatus @default(NONE),
      pcaEffectiveDate DateTime?,
      lastRbiInspectionDate DateTime?,
      rbiRiskRating String?,
      settings Json?, createdAt, updatedAt)
      - **NOTE (D21):** dakshScore, dakshScoreDate, pcaEffectiveDate, lastRbiInspectionDate, rbiRiskRating are NULLABLE — newly onboarded banks won't have these. UI shows "Not yet assessed."

    - User (id UUID, email, name, **roles Role[]** (PostgreSQL array of enum),
      tenantId FK, status, lastLoginAt DateTime?, lastLoginIp String?,
      createdAt, updatedAt)
      - **CRITICAL (D13):** roles is an ARRAY, not a single enum. This enables Tier III/IV banks where one person holds multiple roles (CEO+CAE, CCO+Manager).
      - **CRITICAL (D20):** All permission checks MUST use `user.roles.includes('AUDIT_MANAGER')`, never `user.role === 'AUDIT_MANAGER'`.

    - Session (Better Auth sessions, tenantId FK — Better Auth will manage this table structure)

    **Observation lifecycle models:**
    - Observation (id UUID, tenantId FK, title, condition TEXT, criteria TEXT, cause TEXT, effect TEXT, recommendation TEXT, severity Severity, status ObservationStatus, assignedToId FK, branchId FK, auditAreaId FK, createdById FK, dueDate DateTime?, createdAt, updatedAt, statusUpdatedAt)
    - ObservationTimeline (id UUID, observationId FK, tenantId FK, event String, oldValue String?, newValue String?, comment TEXT?, createdById FK, createdAt)
    - Evidence (id UUID, observationId FK, tenantId FK, filename, s3Key, fileSize Int, contentType, uploadedById FK, deletedAt DateTime?, createdAt)

    **Compliance models:**
    - ComplianceRequirement (id UUID, tenantId FK, requirement TEXT, rbiCircularId FK?, category, status ComplianceStatus, nextReviewDate DateTime?, ownerId FK?, notApplicableReason String?, createdAt, updatedAt)
    - RbiCircular (id UUID, circularNumber unique, title, issuedDate DateTime, url String?) — global, no tenantId

    **Organization models:**
    - Branch (id UUID, tenantId FK, code, name, city, state, type String?)
    - AuditArea (id UUID, tenantId FK, name, description String?, riskCategory String?)

    **Audit planning models:**
    - AuditPlan (id UUID, tenantId FK, year Int, quarter Quarter, status AuditPlanStatus, startDate DateTime?, endDate DateTime?)
    - AuditEngagement (id UUID, auditPlanId FK, tenantId FK, branchId FK?, auditAreaId FK?, assignedToId FK?, status EngagementStatus, scheduledStartDate DateTime?, completionDate DateTime?)

    **Audit trail model (ENRICHED per Skeptic + Domain Expert):**
    - AuditLog (id UUID @default(uuid()), sequenceNumber BigInt @default(autoincrement()),
      tenantId UUID, tableName String, recordId String, operation String,
      actionType String?,
      oldData Json?, newData Json?,
      userId String?, justification String?,
      ipAddress String?, sessionId String?,
      retentionExpiresAt DateTime?,
      createdAt DateTime @default(now()))
      - sequenceNumber: BIGSERIAL for gap detection (Skeptic S4)
      - actionType: business-level action (e.g., "observation.approved") (DE5)
      - justification: required for sensitive ops (DE6)
      - ipAddress, sessionId: RBI cyber security framework (DE review)
      - retentionExpiresAt: computed as createdAt + 10 years (D14, PMLA)

    **Key constraints:**
    - Every model except RbiCircular, Tenant, AuditLog has tenantId UUID @db.Uuid
    - All tenant FKs: `@relation(fields: [tenantId], references: [id], onDelete: Cascade)`
    - Unique constraints include tenantId: `@@unique([tenantId, email])` for User
    - Indexes on tenant_id for all tenant-scoped tables: `@@index([tenantId])`
    - AuditLog has `@@index([tenantId])`, `@@index([tableName, recordId])`, `@@index([actionType])`, `@@index([createdAt])`

    Update package.json scripts:
    ```json
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:seed": "prisma db seed",
    "db:studio": "prisma studio"
    ```

  </action>
  <verify>
    pnpm db:generate
    pnpm db:push --accept-data-loss (creates tables in Docker Postgres)
    psql $DATABASE_URL -c "\dt" (lists all tables)
    psql $DATABASE_URL -c "\d \"User\"" (shows roles column as Role[])
    psql $DATABASE_URL -c "\d \"Tenant\"" (shows dakshScore, pcaStatus columns)
    psql $DATABASE_URL -c "\d \"AuditLog\"" (shows sequenceNumber, actionType, justification, ipAddress, sessionId, retentionExpiresAt)
  </verify>
  <done>
    Prisma schema complete with 15+ models, multi-role users (roles Role[]), enriched audit_log, DAKSH/PCA/NABARD tenant fields, Indian fiscal year quarters, all tenant-scoped tables have tenant_id FK with cascade delete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement RLS policies, FORCE RLS, app role, and audit log immutability</name>
  <files>
    prisma/migrations/add_rls_policies.sql
    prisma/migrations/add_audit_log_rules.sql
    src/lib/prisma.ts
  </files>
  <action>
    Create SQL migrations for RLS, dedicated app role, and audit log immutability:

    **Create prisma/migrations/add_rls_policies.sql:**

    ```sql
    -- Create dedicated application role (NOT superuser)
    DO $$
    BEGIN
      IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'aegis_app') THEN
        CREATE ROLE aegis_app LOGIN PASSWORD 'aegis_app_dev_password';
      END IF;
    END
    $$;

    -- Grant necessary permissions to app role
    GRANT USAGE ON SCHEMA public TO aegis_app;
    GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO aegis_app;
    GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO aegis_app;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO aegis_app;
    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO aegis_app;

    -- Enable RLS on ALL tenant-scoped tables (10 total)
    ALTER TABLE "Tenant" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "User" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "Observation" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "ObservationTimeline" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "Evidence" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "ComplianceRequirement" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "Branch" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "AuditArea" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "AuditPlan" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "AuditEngagement" ENABLE ROW LEVEL SECURITY;

    -- FORCE RLS on ALL 10 tenant-scoped tables (Decision D8, Skeptic S5)
    -- This prevents even the table owner from bypassing RLS
    ALTER TABLE "Tenant" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "User" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "Observation" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "ObservationTimeline" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "Evidence" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "ComplianceRequirement" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "Branch" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "AuditArea" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "AuditPlan" FORCE ROW LEVEL SECURITY;
    ALTER TABLE "AuditEngagement" FORCE ROW LEVEL SECURITY;

    -- Create tenant isolation policies for ALL tenant-scoped tables
    CREATE POLICY tenant_isolation_policy ON "Tenant"
      USING ("id" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "User"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "Observation"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "ObservationTimeline"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "Evidence"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "ComplianceRequirement"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "Branch"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "AuditArea"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "AuditPlan"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    CREATE POLICY tenant_isolation_policy ON "AuditEngagement"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);

    -- Enable RLS on AuditLog (tenant-scoped reading)
    ALTER TABLE "AuditLog" ENABLE ROW LEVEL SECURITY;
    ALTER TABLE "AuditLog" FORCE ROW LEVEL SECURITY;
    CREATE POLICY tenant_isolation_policy ON "AuditLog"
      USING ("tenantId" = current_setting('app.current_tenant_id', TRUE)::uuid);
    ```

    **Create prisma/migrations/add_audit_log_rules.sql:**

    ```sql
    -- AUDIT LOG IMMUTABILITY (FNDN-07, Decision D14, Skeptic S4, DE2)
    -- Prevent UPDATE and DELETE on audit_log at database level
    CREATE RULE prevent_audit_update AS ON UPDATE TO "AuditLog" DO INSTEAD NOTHING;
    CREATE RULE prevent_audit_delete AS ON DELETE TO "AuditLog" DO INSTEAD NOTHING;

    -- Also REVOKE UPDATE and DELETE from app role (belt-and-suspenders)
    REVOKE UPDATE, DELETE ON "AuditLog" FROM aegis_app;

    -- Ensure app role can still INSERT and SELECT
    GRANT INSERT, SELECT ON "AuditLog" TO aegis_app;
    ```

    **Create src/lib/prisma.ts with RLS extension:**

    ```typescript
    import { PrismaClient } from '@prisma/client';

    const prismaClientSingleton = () => {
      return new PrismaClient({
        log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
      });
    };

    declare global {
      var prismaGlobal: undefined | ReturnType<typeof prismaClientSingleton>;
    }

    export const prisma = globalThis.prismaGlobal ?? prismaClientSingleton();

    if (process.env.NODE_ENV !== 'production') {
      globalThis.prismaGlobal = prisma;
    }

    /**
     * Tenant-scoped Prisma client with transaction-scoped RLS.
     *
     * CRITICAL SECURITY NOTES (Decision D6, Skeptic S2):
     * - tenantId MUST come from authenticated session ONLY
     * - NEVER pass tenantId from URL params, request body, or query string
     * - DAL functions should accept a session object, not a raw tenantId string
     * - This function provides RLS-level isolation; DAL functions should ALSO
     *   add explicit WHERE tenantId clauses (belt-and-suspenders, Skeptic S1)
     */
    export function prismaForTenant(tenantId: string) {
      return prisma.$extends({
        query: {
          $allOperations: async ({ operation, model, args, query }) => {
            // Wrap ALL queries in transaction with tenant context
            return prisma.$transaction(async (tx) => {
              // Set LOCAL parameter (transaction-scoped only — safe for connection pooling)
              await tx.$executeRaw`SELECT set_config('app.current_tenant_id', ${tenantId}, TRUE)`;
              return query(args);
            });
          },
        },
      });
    }
    ```

    Run migrations:
    ```bash
    psql $DATABASE_URL < prisma/migrations/add_rls_policies.sql
    psql $DATABASE_URL < prisma/migrations/add_audit_log_rules.sql
    ```

  </action>
  <verify>
    # Verify FORCE RLS on ALL 10 tables + AuditLog
    psql $DATABASE_URL -c "SELECT relname, relrowsecurity, relforcerowsecurity FROM pg_class WHERE relrowsecurity = true ORDER BY relname;"
    # Should show 11 rows (10 tenant-scoped + AuditLog), all with both columns TRUE

    # Verify RLS policies exist
    psql $DATABASE_URL -c "SELECT tablename, policyname FROM pg_policies ORDER BY tablename;"
    # Should show 11 policies (one per table)

    # Verify audit log immutability
    psql -U aegis_app -d aegis -c "INSERT INTO \"AuditLog\" (\"tenantId\", \"tableName\", \"recordId\", \"operation\") VALUES ('00000000-0000-0000-0000-000000000001', 'test', 'test', 'INSERT');"
    # Should succeed
    psql -U aegis_app -d aegis -c "UPDATE \"AuditLog\" SET operation = 'MODIFIED' WHERE \"tableName\" = 'test';"
    # Should do nothing (rule prevents)
    psql -U aegis_app -d aegis -c "DELETE FROM \"AuditLog\" WHERE \"tableName\" = 'test';"
    # Should do nothing (rule prevents)

    # Verify app role exists
    psql $DATABASE_URL -c "SELECT rolname FROM pg_roles WHERE rolname = 'aegis_app';"

  </verify>
  <done>
    RLS policies active on all tenant-scoped tables + AuditLog, FORCE RLS prevents superuser bypass on all 11 tables, aegis_app role created, audit_log is INSERT+SELECT only with PostgreSQL rules blocking UPDATE/DELETE.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create seed script and tenant isolation test</name>
  <files>
    prisma/seed.ts
    scripts/test-tenant-isolation.ts
    package.json
  </files>
  <action>
    Create seed script and tenant isolation test:

    **Create prisma/seed.ts:**

    Import demo data from existing JSON files in src/data/demo/*.json:
    - bank-profile.json → Tenant (with DAKSH/PCA/NABARD fields set to null for new bank)
    - staff.json → User (5 users with ARRAYS of roles, not single role)
    - branches.json → Branch (8 branches)
    - compliance-requirements.json → ComplianceRequirement (55 requirements)
    - findings.json → Observation (35 observations with timeline events)

    **Seeding logic:**
    1. Create Apex Sahakari Bank tenant with tier=TIER_3, scheduledBankStatus=false, dakshScore=null, pcaStatus=NONE
    2. Create 5 users with role ARRAYS: e.g., `roles: ['CAE']`, `roles: ['AUDITOR', 'AUDIT_MANAGER']`
       - At least ONE user should have multiple roles to validate multi-role support
    3. Create 8 branches from branches.json
    4. Create 4 audit areas: Credit Risk, Operational Risk, Compliance, IT Systems
    5. Create audit plans with Quarter using Q1_APR_JUN through Q4_JAN_MAR (Indian fiscal year)
    6. Create 55 compliance requirements from compliance-requirements.json
    7. Create 35 observations from findings.json with branch/area assignment
    8. Create timeline events for each observation (draft → submitted → issued)
    9. Create a SECOND test tenant ("Test Bank B") for isolation testing

    **Handle relations:**
    - Set assignedToId, createdById to actual user IDs
    - Link observations to branches and audit areas
    - Link compliance requirements to audit areas

    **Update package.json:**
    ```json
    "prisma": {
      "seed": "tsx prisma/seed.ts"
    }
    ```

    Install tsx for TypeScript execution:
    ```bash
    pnpm add -D tsx
    ```

    **Create scripts/test-tenant-isolation.ts (Decision D18, DE4):**

    A test script that:
    1. Connects as aegis_app role (not superuser)
    2. Sets tenant context to Tenant A
    3. Queries all tenant-scoped tables — should only see Tenant A data
    4. Sets tenant context to Tenant B
    5. Queries again — should only see Tenant B data
    6. Attempts cross-tenant query (set Tenant A context, query by Tenant B's known record ID)
    7. Verifies 0 rows returned
    8. Generates a simple text report (PDF generation deferred — use plain text for now)
    9. Reports PASS/FAIL for each table

    This serves as both a verification tool and a compliance artifact for RBI inspections.

  </action>
  <verify>
    pnpm db:seed
    psql $DATABASE_URL -c "SELECT COUNT(*) FROM \"Tenant\";" (returns 2 — Apex + Test Bank B)
    psql $DATABASE_URL -c "SELECT COUNT(*) FROM \"User\";" (returns 5+)
    psql $DATABASE_URL -c "SELECT roles FROM \"User\" LIMIT 5;" (shows Role arrays)
    psql $DATABASE_URL -c "SELECT COUNT(*) FROM \"Observation\";" (returns 35)
    psql $DATABASE_URL -c "SELECT COUNT(*) FROM \"ComplianceRequirement\";" (returns 55)
    psql $DATABASE_URL -c "SELECT quarter FROM \"AuditPlan\" LIMIT 1;" (shows Q1_APR_JUN or similar)
    # Run isolation test:
    npx tsx scripts/test-tenant-isolation.ts (all tests PASS)
  </verify>
  <done>
    Seed script runs successfully with 2 tenants (Apex + Test Bank B), multi-role users, Indian fiscal year quarters, nullable DAKSH/PCA fields. Tenant isolation test validates cross-tenant query blocking on all tables.
  </done>
</task>

</tasks>

<verification>
**Schema validation:**
1. All tenant-scoped models have tenantId UUID field
2. All tenant FKs use onDelete: Cascade
3. Indexes exist on tenantId for all tenant-scoped tables
4. RbiCircular model is global (no tenantId)
5. User model has `roles Role[]` (array, not single enum)
6. Tenant model has DAKSH/PCA/NABARD/scheduledBankStatus fields (nullable where appropriate)
7. Quarter enum uses Indian fiscal year (Q1_APR_JUN)
8. AuditLog has sequenceNumber, actionType, justification, ipAddress, sessionId, retentionExpiresAt

**RLS validation:**

1. RLS enabled on all 10 tenant-scoped tables + AuditLog
2. FORCE RLS enabled on ALL 11 tables (not just 4)
3. tenant_isolation_policy exists for each table
4. Policy references current_setting('app.current_tenant_id')

**Audit log immutability (FNDN-07):**

1. PostgreSQL RULE prevents UPDATE on AuditLog
2. PostgreSQL RULE prevents DELETE on AuditLog
3. aegis_app role has INSERT + SELECT only on AuditLog
4. sequenceNumber auto-increments for gap detection

**App role validation:**

1. aegis_app role exists with LOGIN permission
2. aegis_app has appropriate grants on all tables
3. aegis_app CANNOT update/delete audit_log

**Prisma client validation:**

1. prismaForTenant function wraps queries in transaction
2. Transaction sets LOCAL config variable
3. Normal prisma client available for global queries (RbiCircular)
4. Code comments document tenantId source security (Skeptic S2)

**Seed data validation:**

1. 2 tenants created (Apex + Test Bank B)
2. User roles are arrays (at least one user with multiple roles)
3. Observations count matches v1.0 (35 findings)
4. Relations properly connected (assignedTo, branch, auditArea)
5. Quarter values use Indian fiscal year format

**Tenant isolation test:**

1. Test script runs successfully
2. All 10 tenant-scoped tables pass isolation check
3. Cross-tenant query returns 0 rows
4. Report generated
   </verification>

<success_criteria>

1. Prisma generates TypeScript types for all models including roles Role[]
2. Migration applies to database without errors
3. FORCE RLS check: all 11 tables show relforcerowsecurity = true
4. RLS policies block cross-tenant queries (tested via isolation script with aegis_app role)
5. Audit log is immutable: UPDATE and DELETE produce no effect as aegis_app
6. Seed script populates 2 tenants with demo data matching v1.0 counts
7. prismaForTenant function returns scoped client with security documentation
8. At least one seeded user has multiple roles in roles[] array
   </success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-and-migration/05-02-SUMMARY.md`
</output>
