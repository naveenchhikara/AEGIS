---
phase: 16-cicd-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified: []
autonomous: false

must_haves:
  truths:
    - "PRs to main cannot be merged without passing lint, typecheck, build, and e2e checks"
    - "Force pushes to main are prohibited"
    - "Branch protection rules are applied including for repository admins"
  artifacts: []
  key_links:
    - from: "GitHub branch protection rules"
      to: ".github/workflows/ci.yml job names"
      via: "required_status_checks contexts matching job IDs"
      pattern: "lint|typecheck|build|e2e"
---

<objective>
Configure GitHub branch protection rules requiring all CI checks to pass before merge, preventing regressions from reaching production.

Purpose: Enforce that no code reaches main without passing automated validation, closing the gap between having CI and actually requiring it.
Output: Branch protection rules on main requiring lint, typecheck, build, e2e status checks.
</objective>

<execution_context>
@/Users/admin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/admin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-cicd-pipeline/16-01-SUMMARY.md
@.planning/phases/16-cicd-pipeline/16-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure branch protection rules via gh CLI</name>
  <files></files>
  <action>
Use the gh CLI to configure branch protection on the main branch. This requires the CI workflow to have run at least once on main (so GitHub recognizes the check names).

**Step 1 — Pre-check:** Verify CI has run on main at least once (GitHub only recognizes check names after first run):

```bash
gh run list --workflow=ci.yml --branch=main --limit=1
```

If no runs exist, trigger one and wait:

```bash
gh workflow run ci.yml --ref main
# Wait for completion
gh run watch --exit-status
```

**Step 2 — Fetch exact check names:** GitHub records check names that may differ from raw job IDs (e.g., could be `lint` or `CI / lint` depending on GitHub's naming). Fetch the actual names from a completed run:

```bash
# Get the latest completed run ID on main
RUN_ID=$(gh run list --workflow=ci.yml --branch=main --status=completed --limit=1 --json databaseId --jq '.[0].databaseId')

# Fetch all check suite/run names from that run
gh api "repos/{owner}/{repo}/commits/$(gh run view $RUN_ID --json headSha --jq '.headSha')/check-runs" \
  --jq '.check_runs[].name'
```

Use the EXACT names returned (e.g., `lint`, `typecheck`, `build`, `e2e`) in the `contexts` array below. If GitHub prefixes them (e.g., `CI / lint`), use the prefixed form.

**Step 3 — Configure branch protection:**

```bash
# Replace CHECK_NAMES with actual names from Step 2
gh api -X PUT "repos/{owner}/{repo}/branches/main/protection" \
  --input - <<EOF
{
  "required_status_checks": {
    "strict": true,
    "contexts": ["lint", "typecheck", "build", "e2e"]
  },
  "enforce_admins": true,
  "required_pull_request_reviews": null,
  "restrictions": null,
  "allow_force_pushes": false,
  "allow_deletions": false
}
EOF
```

**CRITICAL:** If Step 2 shows different names than `lint`/`typecheck`/`build`/`e2e`, update the `contexts` array to match. Mismatched names will permanently block or silently skip merge protection.

**Key details:**

- `strict: true` requires branches to be up-to-date before merging (prevents stale-merge regressions)
- `contexts` must list EXACT check names from a completed run — NOT deploy (deploy only runs on main, not PRs)
- `enforce_admins: true` applies rules even to repo administrators
- `required_pull_request_reviews: null` does not require PR reviews (solo developer workflow)
- `restrictions: null` does not restrict who can push
- `allow_force_pushes: false` preserves audit trail
- `allow_deletions: false` prevents accidental branch deletion

**If gh CLI auth fails:** This is expected if the GitHub token doesn't have admin:repo permissions. Provide fallback instructions for manual configuration via GitHub UI:

1. Go to repository Settings -> Branches -> Add branch protection rule
2. Branch name pattern: `main`
3. Check "Require status checks to pass before merging"
4. Search and select the exact check names from a completed CI run (likely: lint, typecheck, build, e2e)
5. Check "Require branches to be up to date before merging"
6. Check "Include administrators"
7. Uncheck "Allow force pushes"
   </action>
   <verify>
   Verify branch protection is set: `gh api "repos/{owner}/{repo}/branches/main/protection" --jq '.required_status_checks.contexts'`
   Expected output should include: lint, typecheck, build, e2e
   Verify enforce_admins: `gh api "repos/{owner}/{repo}/branches/main/protection" --jq '.enforce_admins.enabled'` should return true
   </verify>
   <done>Branch protection rules configured on main requiring lint, typecheck, build, and e2e status checks to pass before merge</done>
   </task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify CI pipeline and branch protection end-to-end</name>
  <files></files>
  <action>
CHECKPOINT: Human verification of complete CI/CD pipeline.

What was built: Complete CI/CD pipeline with GitHub Actions workflow (lint, typecheck, build, e2e, deploy) and branch protection rules on main branch.

Verification steps for user:

1. **Verify GitHub Secrets are configured:**
   - Go to GitHub repo -> Settings -> Secrets and variables -> Actions
   - Confirm COOLIFY_WEBHOOK_URL and COOLIFY_API_TOKEN secrets exist (add them if missing)

2. **Verify CI workflow runs:**
   - Go to GitHub repo -> Actions tab
   - Confirm the "CI" workflow appears in the sidebar
   - Check that the most recent run on main shows all 5 jobs (lint, typecheck, build, e2e, deploy)

3. **Test branch protection:**
   - Create a test branch: `git checkout -b test/ci-verify`
   - Make a trivial change (e.g., add a comment to any file)
   - Push and create a PR to main
   - Verify that the PR shows "Required checks" and merge is blocked until they pass
   - Close the PR without merging, delete the test branch

4. **Verify deploy job:**
   - Check the most recent main push workflow run
   - If COOLIFY_WEBHOOK_URL secret is configured: deploy job runs and shows "Trigger Coolify deployment" step
   - If COOLIFY_WEBHOOK_URL secret is NOT configured: deploy job is correctly skipped (gated on secret presence)

Resume signal: Type "approved" if CI pipeline and branch protection work correctly, or describe any issues.
</action>
<verify>User confirms CI pipeline runs on push/PR, branch protection blocks merge without passing checks, deploy job triggers on main</verify>
<done>End-to-end CI/CD pipeline verified: automated testing on every change, branch protection enforced, Coolify deployment triggered on main</done>
</task>

</tasks>

<verification>
1. CI workflow has run successfully on main at least once
2. Branch protection rule exists on main
3. Status checks lint, typecheck, build, e2e are required
4. Force push is disabled on main
5. Admin enforcement is enabled
</verification>

<success_criteria>

- PRs to main show required status checks and cannot merge until all pass
- Force pushes to main are blocked
- Admin users are subject to the same protection rules
- CI pipeline runs automatically on push/PR to main
  </success_criteria>

<output>
After completion, create `.planning/phases/16-cicd-pipeline/16-02-SUMMARY.md`
</output>
